{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lanelet2 Overview Lanelet2 is a C++ library for handling map data in the context of automated driving. It is designed to utilize high-definition map data in order to efficiently handle the challenges posed to a vehicle in complex traffic scenarios. Flexibility and extensibility are some of the core principles to handle the upcoming challenges of future maps. Features: - 2D and 3D support - Consistent modification : if one point is modified, all owning objects see the change - Supports lane changes , routing through areas, etc. - Separated routing for pedestrians, vehicles, bikes, etc. - Many customization points to add new traffic rules, routing costs, parsers, etc. - Simple convenience functions for common tasks when handling maps - Accurate Projection between the lat/lon geographic world and local metric coordinates - IO Interface for reading and writing e.g. osm data formats (this does not mean it can deal with osm maps ) - Python bindings for the whole C++ interface - Boost Geometry support for all thinkable kinds of geometry calculations on map primitives - Released under the BSD 3-Clause license - Support for ROS1, ROS2, Docker and Conan (see instructions below) Lanelet2 is the successor of the old liblanelet that was developed in 2013. If you know Lanelet1, you might be interested in reading this . Documentation You can find more documentation in the individual packages and in doxygen comments. Here is an overview on the most important topics: - Here is more information on the basic primitives that make up a Lanelet2 map. - Read here for a primer on the software architecture of lanelet2. - There is also some documentation on the geometry calculations you can do with lanelet2 primitives. - If you are interested in Lanelet2's projections , you will find more here . - To get more information on how to create valid maps, see here . You can also find the documentation at this link . Installation Within ROS Lanelet2 has been released for ROS. Just install ros-[distribution]-lanelet2 , e.g.: sudo apt install ros-noetic-lanelet2 Without ROS Outside of ROS, Lanelet2 can be installed from PyPI. Note that currently only Python 3.8-3.11 linux builds are available and that Python 3.10+ is only supported for recent linux distributions such as Ubuntu 20.04+. pip install lanelet2 Note: If you receive the error ERROR: Could not find a version that satisfies the requirement lanelet2 (from versions: none) ERROR: No matching distribution found for lanelet2 during installation, even when using e.g. python 3.9 or 3.8 on a somewhat recent linux such as Ubuntu 18.04 or newer, your pip version is probably too old, as e.g. the pip version that comes with apt on Ubuntu 20.04 (20.0.2) is not recent enough for the provided package. In this case you need to simply update pip with pip3 install -U pip Using Docker There is a Docker container from which you can test things out: docker build -t lanelet2 . # builds a docker image named \"lanelet2\" docker run -it --rm lanelet2:latest /bin/bash # starts the docker image python -c \"import lanelet2\" # quick check to see everything is fine The docker image contains a link to your local lanelet2, so you can work and see changes (almost) at the same time. Work with two screens, one local and one on docker. Make your code changes locally, then run again catkin build on docker to recompile the code (update python modules). Manual installation In case you want to build it in your own way (without the above Docker image) use these instructions. Lanelet2 relies mainly on Catkin for building and is targeted towards Linux. At least C++14 is required. Dependencies Besides Catkin , the dependencies are * Boost (from 1.58) * eigen3 * mrt_cmake_modules , a CMake helper library * pugixml (for lanelet2_io) * boost-python, python2 or python3 (for lanelet2_python) * geographiclib (for lanelet2_projection) * rosbash (for lanelet2_examples) For Ubuntu, the steps are the following: * Set up ROS , and install at least rospack , catkin and mrt_cmake_modules (e.g. ros-melodic-rospack , ros-melodic-catkin , ros-melodic-mrt-cmake-modules ): sudo apt-get install ros-melodic-rospack ros-melodic-catkin ros-melodic-mrt-cmake-modules Install the dependencies above: sudo apt-get install libboost-dev libeigen3-dev libgeographic-dev libpugixml-dev libpython-dev libboost-python-dev python-catkin-tools On 16.04 and below , mrt_cmake_modules is not available in ROS and you have to clone it into your workspace ( git clone https://github.com/KIT-MRT/mrt_cmake_modules.git ). Building As usual with Catkin, after you have sourced the ros installation, you have to create a workspace and clone all required packages there. Then you can build. source /opt/ros/$ROS_DISTRO/setup.bash mkdir catkin_ws && cd catkin_ws && mkdir src catkin init catkin config --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo # build in release mode (or whatever you prefer) cd src git clone https://github.com/fzi-forschungszentrum-informatik/lanelet2.git cd .. catkin build If unsure, see the Dockerfile or the travis build log . It shows the full installation process, with subsequent build and test based on a docker image with a clean Ubuntu installation. Manual, experimental installation using conan Note: Updated instructions for conan2! For non-catkin users, we also offer a conan based install process. Its experimental and might not work on all platforms, especially Windows. Since conan handles installing all C++ dependencies, all you need is a cloned repository, conan itself and a few python dependencies: pip install conan catkin_pkg numpy git clone https://github.com/fzi-forschungszentrum-informatik/lanelet2.git cd lanelet2 From here, just use the default conan build/install procedure, e.g.: conan create . --build=missing Different from the conan defaults, we build lanelet2 and boost as shared libraries, because otherwise the lanelet2's plugin mechanisms as well as boost::python will fail. E.g. loading maps will not be possible and the python API will not be usable. To be able to use the python bindings, you have to make conan export the PYTHONPATH for lanelet2 after conan create : source activate.sh python -c \"import lanelet2\" # or whatever you want to do source deactivate.sh Python3 The python bindings are build for your default python installation by default (which currently is python2 on most systems). To build for python3 instead of python2, create a python3 virtualenv before initializing the workspace with catkin init . The command python should point to python3 . After catkin init run catkin config --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo -DPYTHON_VERSION=3.6 to make sure that the correct python version is used. Then build and use as usual. Note: With bionic and beyond, the apt package python3-catkin-tools conflicts with ROS melodic and should not be used. Use either the python2 version or use pip to install the python3 version. Examples Examples and common use cases in both C++ and Python can be found here . Packages lanelet2 is the meta-package for the whole lanelet2 framework lanelet2_core implements the basic library with all the primitives, geometry calculations and the LanletMap object lanelet2_io is responsible for reading and writing lanelet maps lanelet2_traffic_rules provides support to interpret the traffic rules encoded in a map lanelet2_projection for projecting maps from WGS84 (lat/lon) to local metric coordinates lanelet2_routing implements the routing graph for routing or reachable set or queries as well as collision checking lanelet2_maps provides example maps and functionality to visualize and modify them easily in JOSM lanelet2_matching provides functions to determine in which lanelet an object is/could be currently located lanelet2_python implements the python interface for lanelet2 lanelet2_validation provides checks to ensure a valid lanelet2 map lanelet2_examples contains tutorials for working with Lanelet2 in C++ and Python Citation If you are using Lanelet2 for scientific research, we would be pleased if you would cite our publication : @inproceedings{poggenhans2018lanelet2, title = {Lanelet2: A High-Definition Map Framework for the Future of Automated Driving}, author = {Poggenhans, Fabian and Pauls, Jan-Hendrik and Janosovits, Johannes and Orf, Stefan and Naumann, Maximilian and Kuhnt, Florian and Mayr, Matthias}, booktitle = {Proc.\\ IEEE Intell.\\ Trans.\\ Syst.\\ Conf.}, year = {2018}, address = {Hawaii, USA}, owner = {poggenhans}, month = {November}, Url={http://www.mrt.kit.edu/z/publ/download/2018/Poggenhans2018Lanelet2.pdf} }","title":"Home"},{"location":"#lanelet2","text":"","title":"Lanelet2"},{"location":"#overview","text":"Lanelet2 is a C++ library for handling map data in the context of automated driving. It is designed to utilize high-definition map data in order to efficiently handle the challenges posed to a vehicle in complex traffic scenarios. Flexibility and extensibility are some of the core principles to handle the upcoming challenges of future maps. Features: - 2D and 3D support - Consistent modification : if one point is modified, all owning objects see the change - Supports lane changes , routing through areas, etc. - Separated routing for pedestrians, vehicles, bikes, etc. - Many customization points to add new traffic rules, routing costs, parsers, etc. - Simple convenience functions for common tasks when handling maps - Accurate Projection between the lat/lon geographic world and local metric coordinates - IO Interface for reading and writing e.g. osm data formats (this does not mean it can deal with osm maps ) - Python bindings for the whole C++ interface - Boost Geometry support for all thinkable kinds of geometry calculations on map primitives - Released under the BSD 3-Clause license - Support for ROS1, ROS2, Docker and Conan (see instructions below) Lanelet2 is the successor of the old liblanelet that was developed in 2013. If you know Lanelet1, you might be interested in reading this .","title":"Overview"},{"location":"#documentation","text":"You can find more documentation in the individual packages and in doxygen comments. Here is an overview on the most important topics: - Here is more information on the basic primitives that make up a Lanelet2 map. - Read here for a primer on the software architecture of lanelet2. - There is also some documentation on the geometry calculations you can do with lanelet2 primitives. - If you are interested in Lanelet2's projections , you will find more here . - To get more information on how to create valid maps, see here . You can also find the documentation at this link .","title":"Documentation"},{"location":"#installation","text":"","title":"Installation"},{"location":"#within-ros","text":"Lanelet2 has been released for ROS. Just install ros-[distribution]-lanelet2 , e.g.: sudo apt install ros-noetic-lanelet2","title":"Within ROS"},{"location":"#without-ros","text":"Outside of ROS, Lanelet2 can be installed from PyPI. Note that currently only Python 3.8-3.11 linux builds are available and that Python 3.10+ is only supported for recent linux distributions such as Ubuntu 20.04+. pip install lanelet2","title":"Without ROS"},{"location":"#note","text":"If you receive the error ERROR: Could not find a version that satisfies the requirement lanelet2 (from versions: none) ERROR: No matching distribution found for lanelet2 during installation, even when using e.g. python 3.9 or 3.8 on a somewhat recent linux such as Ubuntu 18.04 or newer, your pip version is probably too old, as e.g. the pip version that comes with apt on Ubuntu 20.04 (20.0.2) is not recent enough for the provided package. In this case you need to simply update pip with pip3 install -U pip","title":"Note:"},{"location":"#using-docker","text":"There is a Docker container from which you can test things out: docker build -t lanelet2 . # builds a docker image named \"lanelet2\" docker run -it --rm lanelet2:latest /bin/bash # starts the docker image python -c \"import lanelet2\" # quick check to see everything is fine The docker image contains a link to your local lanelet2, so you can work and see changes (almost) at the same time. Work with two screens, one local and one on docker. Make your code changes locally, then run again catkin build on docker to recompile the code (update python modules).","title":"Using Docker"},{"location":"#manual-installation","text":"In case you want to build it in your own way (without the above Docker image) use these instructions. Lanelet2 relies mainly on Catkin for building and is targeted towards Linux. At least C++14 is required.","title":"Manual installation"},{"location":"#dependencies","text":"Besides Catkin , the dependencies are * Boost (from 1.58) * eigen3 * mrt_cmake_modules , a CMake helper library * pugixml (for lanelet2_io) * boost-python, python2 or python3 (for lanelet2_python) * geographiclib (for lanelet2_projection) * rosbash (for lanelet2_examples) For Ubuntu, the steps are the following: * Set up ROS , and install at least rospack , catkin and mrt_cmake_modules (e.g. ros-melodic-rospack , ros-melodic-catkin , ros-melodic-mrt-cmake-modules ): sudo apt-get install ros-melodic-rospack ros-melodic-catkin ros-melodic-mrt-cmake-modules Install the dependencies above: sudo apt-get install libboost-dev libeigen3-dev libgeographic-dev libpugixml-dev libpython-dev libboost-python-dev python-catkin-tools On 16.04 and below , mrt_cmake_modules is not available in ROS and you have to clone it into your workspace ( git clone https://github.com/KIT-MRT/mrt_cmake_modules.git ).","title":"Dependencies"},{"location":"#building","text":"As usual with Catkin, after you have sourced the ros installation, you have to create a workspace and clone all required packages there. Then you can build. source /opt/ros/$ROS_DISTRO/setup.bash mkdir catkin_ws && cd catkin_ws && mkdir src catkin init catkin config --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo # build in release mode (or whatever you prefer) cd src git clone https://github.com/fzi-forschungszentrum-informatik/lanelet2.git cd .. catkin build If unsure, see the Dockerfile or the travis build log . It shows the full installation process, with subsequent build and test based on a docker image with a clean Ubuntu installation.","title":"Building"},{"location":"#manual-experimental-installation-using-conan","text":"Note: Updated instructions for conan2! For non-catkin users, we also offer a conan based install process. Its experimental and might not work on all platforms, especially Windows. Since conan handles installing all C++ dependencies, all you need is a cloned repository, conan itself and a few python dependencies: pip install conan catkin_pkg numpy git clone https://github.com/fzi-forschungszentrum-informatik/lanelet2.git cd lanelet2 From here, just use the default conan build/install procedure, e.g.: conan create . --build=missing Different from the conan defaults, we build lanelet2 and boost as shared libraries, because otherwise the lanelet2's plugin mechanisms as well as boost::python will fail. E.g. loading maps will not be possible and the python API will not be usable. To be able to use the python bindings, you have to make conan export the PYTHONPATH for lanelet2 after conan create : source activate.sh python -c \"import lanelet2\" # or whatever you want to do source deactivate.sh","title":"Manual, experimental installation using conan"},{"location":"#python3","text":"The python bindings are build for your default python installation by default (which currently is python2 on most systems). To build for python3 instead of python2, create a python3 virtualenv before initializing the workspace with catkin init . The command python should point to python3 . After catkin init run catkin config --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo -DPYTHON_VERSION=3.6 to make sure that the correct python version is used. Then build and use as usual. Note: With bionic and beyond, the apt package python3-catkin-tools conflicts with ROS melodic and should not be used. Use either the python2 version or use pip to install the python3 version.","title":"Python3"},{"location":"#examples","text":"Examples and common use cases in both C++ and Python can be found here .","title":"Examples"},{"location":"#packages","text":"lanelet2 is the meta-package for the whole lanelet2 framework lanelet2_core implements the basic library with all the primitives, geometry calculations and the LanletMap object lanelet2_io is responsible for reading and writing lanelet maps lanelet2_traffic_rules provides support to interpret the traffic rules encoded in a map lanelet2_projection for projecting maps from WGS84 (lat/lon) to local metric coordinates lanelet2_routing implements the routing graph for routing or reachable set or queries as well as collision checking lanelet2_maps provides example maps and functionality to visualize and modify them easily in JOSM lanelet2_matching provides functions to determine in which lanelet an object is/could be currently located lanelet2_python implements the python interface for lanelet2 lanelet2_validation provides checks to ensure a valid lanelet2 map lanelet2_examples contains tutorials for working with Lanelet2 in C++ and Python","title":"Packages"},{"location":"#citation","text":"If you are using Lanelet2 for scientific research, we would be pleased if you would cite our publication : @inproceedings{poggenhans2018lanelet2, title = {Lanelet2: A High-Definition Map Framework for the Future of Automated Driving}, author = {Poggenhans, Fabian and Pauls, Jan-Hendrik and Janosovits, Johannes and Orf, Stefan and Naumann, Maximilian and Kuhnt, Florian and Mayr, Matthias}, booktitle = {Proc.\\ IEEE Intell.\\ Trans.\\ Syst.\\ Conf.}, year = {2018}, address = {Hawaii, USA}, owner = {poggenhans}, month = {November}, Url={http://www.mrt.kit.edu/z/publ/download/2018/Poggenhans2018Lanelet2.pdf} }","title":"Citation"},{"location":"lanelet2_core/","text":"Lanelet2 Core For an overview on the Lanelet2 architecture, see here This package contains the core library of Lanelet2: - The basic primitives , including LaneletMap - Geometry functions For usage examples, please refer to the lanelet2_examples package. Debugging Debugging Lanelet objects can be annoying, because they are very deeply nested. To improve this, Lanelet2 offers helpers for GDB and QtCreator . Have a look here .","title":"lanelet2_core"},{"location":"lanelet2_core/#lanelet2-core","text":"For an overview on the Lanelet2 architecture, see here This package contains the core library of Lanelet2: - The basic primitives , including LaneletMap - Geometry functions For usage examples, please refer to the lanelet2_examples package.","title":"Lanelet2 Core"},{"location":"lanelet2_core/#debugging","text":"Debugging Lanelet objects can be annoying, because they are very deeply nested. To improve this, Lanelet2 offers helpers for GDB and QtCreator . Have a look here .","title":"Debugging"},{"location":"lanelet2_examples/","text":"Lanelet2 Examples This package contains executable usage examples for people who would like to know how to work with a lanelet2 map. Simply look at the code in the individual lessons. They are equipped with lots of explaining comments. You can also build and run them to see them in action. The examples are divided into individual lessons that help you step by step to understand lanelet2. Simply look here for an overview on the C++ tutorials. The python tutorials are shorter and demonstrate the similarity of the interface. They can be found here .","title":"lanelet2_examples"},{"location":"lanelet2_examples/#lanelet2-examples","text":"This package contains executable usage examples for people who would like to know how to work with a lanelet2 map. Simply look at the code in the individual lessons. They are equipped with lots of explaining comments. You can also build and run them to see them in action. The examples are divided into individual lessons that help you step by step to understand lanelet2. Simply look here for an overview on the C++ tutorials. The python tutorials are shorter and demonstrate the similarity of the interface. They can be found here .","title":"Lanelet2 Examples"},{"location":"lanelet2_io/","text":"Lanelet2 IO IO Module for parsing and writing LaneletMaps. It contains a various reader/writer functions for different formats. Which format will be used is determined the extension of the given filename. If a writer/parser is registered for this extension, it will be chosen automatically. Currently available IO modules are: - OSM (.osm) writes/loads specialized lanelet maps from OpenStreetMap html files. See maps module for a primer on this. - Binary (.bin) writes/loads the map to/from an internal bin format. Very efficient for writing and reading but not human-readable Projections Most IO modules require a projection from WGS84 (lat/lon) to a local metric coordinate system. To make sure the loaded map is correct in itself it is very important to choose the correct origin and the correct projector. The origin should be as close to where the map is as possible. For an overview on projections, have a look at the projection module . Usage Here is an example of how to read a file from .osm and write it back out as .bin: #include <lanelet2_io/io.h> std::string filename_in = \"mymap.osm\"; lanelet::Origin origin(49.0, 8.4); lanelet::LaneletMapPtr laneletMap = lanelet::load(filenameIn, origin); std::string filename_out = \"mymap.bin\"; lanelet::write(filenameOut, *laneletMap);","title":"lanelet2_io"},{"location":"lanelet2_io/#lanelet2-io","text":"IO Module for parsing and writing LaneletMaps. It contains a various reader/writer functions for different formats. Which format will be used is determined the extension of the given filename. If a writer/parser is registered for this extension, it will be chosen automatically. Currently available IO modules are: - OSM (.osm) writes/loads specialized lanelet maps from OpenStreetMap html files. See maps module for a primer on this. - Binary (.bin) writes/loads the map to/from an internal bin format. Very efficient for writing and reading but not human-readable","title":"Lanelet2 IO"},{"location":"lanelet2_io/#projections","text":"Most IO modules require a projection from WGS84 (lat/lon) to a local metric coordinate system. To make sure the loaded map is correct in itself it is very important to choose the correct origin and the correct projector. The origin should be as close to where the map is as possible. For an overview on projections, have a look at the projection module .","title":"Projections"},{"location":"lanelet2_io/#usage","text":"Here is an example of how to read a file from .osm and write it back out as .bin: #include <lanelet2_io/io.h> std::string filename_in = \"mymap.osm\"; lanelet::Origin origin(49.0, 8.4); lanelet::LaneletMapPtr laneletMap = lanelet::load(filenameIn, origin); std::string filename_out = \"mymap.bin\"; lanelet::write(filenameOut, *laneletMap);","title":"Usage"},{"location":"lanelet2_maps/","text":"Lanelet2 Maps This repo contains tools for creating and modifying maps. Editing Lanelet2 maps Lanelet2 maps are best edited using the OpenStreetMap-Editor JOSM . The josm folder of this package contains styles and presets for simple set-up. This repository contains two stylesheets. One for visualizing the physical layer of the map (the markings and borders) and one for visualizing the lanelet/area layer. To use them in JOSM: - Unzip the images in style_images.zip (containing images for traffic signs) - Under Preferences->Map Settings -> Map Paint styles -> add (+) select lanelets.mapcss and lines.mapcss to add the lanelet2 styles to JOSM. - Under Preferences->Map Settings -> Tagging Presets -> add (+) select laneletpresets.xml to add the lanelet2 tagging style to JOSM After that, you can access the presets via Presets->lanelet2. For faster access, add them to the toolbar in Preferences->Toolbar customization. Reading and Writing to OSM Lanelet2 utilizes the osm xml format as default format to read and write map data. To do this, a simple mapping is done by the library to \"transform\" lanelet primitives into osm primitives. The Id will be the Id of the primitive (we recommend to use positive Ids, because some OSM editors treat negative Ids as something modifiable and will continue to change them), attributes will be translated to tags of the OSM primitive. Points Points are directly transformed to OSM Nodes . The \"ele\" tag is used to represent the z-coordinate of the point. It denotes the distance to the earth ellipsoid in WGS84. LineStrings LineStrings are transformed to OSM Ways . Polygons Polygons are OSM Ways as well but are identified by a tag area=yes . Start point = end point is not sufficient and also not necessary. Lanelets Lanelets are represented as OSM relations with a tag type=lanelet . - The right bound is a relation member of type way with role right - The left bound is a relation member of type way with role left - The centerline (if present) is a relation member of type way with role centerline - All regulatory elements are relation members of type relation with the role regulatory_element If there are more members to the lanelet relation than the mentioned ones, Lanelet2 will raise an error. Areas Areas are represented as OSM relations by making use of the multipolygon representation. They have a tag type=multipolygon . The outer bound is an ordered list of relation members with the roles outer , the inner bounds are an ordered list of relation members with the roles inner . Lanelet2 parses the inner bounds in this order and starts a new hole whenever the last point of one linestring matches the first one. Regulatory Elements Regulatory elements are also represented as OSM relations with type=regulatory_element the parameters of a role are directly translated to relations. All other relations (with no type or a wrong type) will be ignored when parsing .osm data.","title":"lanelet2_maps"},{"location":"lanelet2_maps/#lanelet2-maps","text":"This repo contains tools for creating and modifying maps.","title":"Lanelet2 Maps"},{"location":"lanelet2_maps/#editing-lanelet2-maps","text":"Lanelet2 maps are best edited using the OpenStreetMap-Editor JOSM . The josm folder of this package contains styles and presets for simple set-up. This repository contains two stylesheets. One for visualizing the physical layer of the map (the markings and borders) and one for visualizing the lanelet/area layer. To use them in JOSM: - Unzip the images in style_images.zip (containing images for traffic signs) - Under Preferences->Map Settings -> Map Paint styles -> add (+) select lanelets.mapcss and lines.mapcss to add the lanelet2 styles to JOSM. - Under Preferences->Map Settings -> Tagging Presets -> add (+) select laneletpresets.xml to add the lanelet2 tagging style to JOSM After that, you can access the presets via Presets->lanelet2. For faster access, add them to the toolbar in Preferences->Toolbar customization.","title":"Editing Lanelet2 maps"},{"location":"lanelet2_maps/#reading-and-writing-to-osm","text":"Lanelet2 utilizes the osm xml format as default format to read and write map data. To do this, a simple mapping is done by the library to \"transform\" lanelet primitives into osm primitives. The Id will be the Id of the primitive (we recommend to use positive Ids, because some OSM editors treat negative Ids as something modifiable and will continue to change them), attributes will be translated to tags of the OSM primitive.","title":"Reading and Writing to OSM"},{"location":"lanelet2_maps/#points","text":"Points are directly transformed to OSM Nodes . The \"ele\" tag is used to represent the z-coordinate of the point. It denotes the distance to the earth ellipsoid in WGS84.","title":"Points"},{"location":"lanelet2_maps/#linestrings","text":"LineStrings are transformed to OSM Ways .","title":"LineStrings"},{"location":"lanelet2_maps/#polygons","text":"Polygons are OSM Ways as well but are identified by a tag area=yes . Start point = end point is not sufficient and also not necessary.","title":"Polygons"},{"location":"lanelet2_maps/#lanelets","text":"Lanelets are represented as OSM relations with a tag type=lanelet . - The right bound is a relation member of type way with role right - The left bound is a relation member of type way with role left - The centerline (if present) is a relation member of type way with role centerline - All regulatory elements are relation members of type relation with the role regulatory_element If there are more members to the lanelet relation than the mentioned ones, Lanelet2 will raise an error.","title":"Lanelets"},{"location":"lanelet2_maps/#areas","text":"Areas are represented as OSM relations by making use of the multipolygon representation. They have a tag type=multipolygon . The outer bound is an ordered list of relation members with the roles outer , the inner bounds are an ordered list of relation members with the roles inner . Lanelet2 parses the inner bounds in this order and starts a new hole whenever the last point of one linestring matches the first one.","title":"Areas"},{"location":"lanelet2_maps/#regulatory-elements","text":"Regulatory elements are also represented as OSM relations with type=regulatory_element the parameters of a role are directly translated to relations. All other relations (with no type or a wrong type) will be ignored when parsing .osm data.","title":"Regulatory Elements"},{"location":"lanelet2_matching/","text":"Lanelet2 Matching Module This module provides functions to determine in which lanelet an object is/could be currently located. Matching functions Deterministic matching : Find all lanelets to which an object has less than a certain Euclidean distance. as lanelets have an orientation, every lanelet is considered twice: regular and inverted, but with the same distance Probabilistic matching : Compute the squared Mahalanobis distance of the object pose to the lanelet to reason about the probability of that match, as suggested by Petrich et al. ( DOI:0.1109/ITSC.2013.6728549 ) this distance includes the orientation, thus every lanelet is considered twice: regular and inverted, but with different distances Accounting for traffic rules : In case you expect traffic rule compliant behavior, you can remove non-compliant matches by providing a traffic rule element for the participant you were matching (such as pedestrian lanelets for vehicles or inverted one way lanelets, which means driving in the wrong direction). Usage C++ #include <lanelet2_matching/LaneletMatching.h> // create objects to match lanelet::matching::Object2d obj; // deterministic lanelet::matching::ObjectWithCovariance2d obj2; // considering uncertainty // retrieve lanelet matches from map auto detMatches = getDeterministicMatches(laneletMap, obj, 4.); // max distance = 4m auto probMatches = getProbabilisticMatches(laneletMap, obj2, 4.); // max distance = 4m // remove non-compliant matches (such as driving in the wrong direction) auto compliantDetMatches = removeNonRuleCompliantMatches(detMatches, trafficRulesPtr); auto compliantProbMatches = removeNonRuleCompliantMatches(probMatches, trafficRulesPtr); have a look at the C++ unittests for more examples Python import lanelet2 # Note: in the standalone version of lanelet2_matching, the python module was named # \"lanelet2_matching\". Now it is a submodule of lanelet2: \"lanelet2.matching\" # create objects to match obj = lanelet2.matching.Object2d() # retrieve lanelet matches from map matches = lanelet2.matching.getDeterministicMatches(lanelet_map, obj, 4.) # max distance = 4m # remove non-compliant matches (such as driving in the wrong direction) compliant_matches = lanelet2.matching.removeNonRuleCompliantMatches(matches, traffic_rules) have a look at the python unittests for more examples, also supports uncertainty License This package is distributed under the 3-Clause BSD License, see LICENSE .","title":"lanelet2_matching"},{"location":"lanelet2_matching/#lanelet2-matching-module","text":"This module provides functions to determine in which lanelet an object is/could be currently located.","title":"Lanelet2 Matching Module"},{"location":"lanelet2_matching/#matching-functions","text":"Deterministic matching : Find all lanelets to which an object has less than a certain Euclidean distance. as lanelets have an orientation, every lanelet is considered twice: regular and inverted, but with the same distance Probabilistic matching : Compute the squared Mahalanobis distance of the object pose to the lanelet to reason about the probability of that match, as suggested by Petrich et al. ( DOI:0.1109/ITSC.2013.6728549 ) this distance includes the orientation, thus every lanelet is considered twice: regular and inverted, but with different distances Accounting for traffic rules : In case you expect traffic rule compliant behavior, you can remove non-compliant matches by providing a traffic rule element for the participant you were matching (such as pedestrian lanelets for vehicles or inverted one way lanelets, which means driving in the wrong direction).","title":"Matching functions"},{"location":"lanelet2_matching/#usage","text":"","title":"Usage"},{"location":"lanelet2_matching/#c","text":"#include <lanelet2_matching/LaneletMatching.h> // create objects to match lanelet::matching::Object2d obj; // deterministic lanelet::matching::ObjectWithCovariance2d obj2; // considering uncertainty // retrieve lanelet matches from map auto detMatches = getDeterministicMatches(laneletMap, obj, 4.); // max distance = 4m auto probMatches = getProbabilisticMatches(laneletMap, obj2, 4.); // max distance = 4m // remove non-compliant matches (such as driving in the wrong direction) auto compliantDetMatches = removeNonRuleCompliantMatches(detMatches, trafficRulesPtr); auto compliantProbMatches = removeNonRuleCompliantMatches(probMatches, trafficRulesPtr); have a look at the C++ unittests for more examples","title":"C++"},{"location":"lanelet2_matching/#python","text":"import lanelet2 # Note: in the standalone version of lanelet2_matching, the python module was named # \"lanelet2_matching\". Now it is a submodule of lanelet2: \"lanelet2.matching\" # create objects to match obj = lanelet2.matching.Object2d() # retrieve lanelet matches from map matches = lanelet2.matching.getDeterministicMatches(lanelet_map, obj, 4.) # max distance = 4m # remove non-compliant matches (such as driving in the wrong direction) compliant_matches = lanelet2.matching.removeNonRuleCompliantMatches(matches, traffic_rules) have a look at the python unittests for more examples, also supports uncertainty","title":"Python"},{"location":"lanelet2_matching/#license","text":"This package is distributed under the 3-Clause BSD License, see LICENSE .","title":"License"},{"location":"lanelet2_projection/","text":"Lanelet2 Projection Module This module implements different projection functions as required by lanelet2_io . Need for projections As map data is commonly stored in WGS84 (lat/lon/ele) and lanelet2 operates on metrical data, there is a need for precise projection functions between the two. There are very good projection functions available, but they have to be used with the correct origin (close to the location of the map). Maps loaded with a wrong origin can easily be distorted by 40% and more. Angle calculations will be wrong as well. For more details, read here . Supported Projections UTM.h : WGS84 (for storage in .osm files) <-> UTM (internal processing) (wrapper of https://sourceforge.net/projects/geographiclib/). This projection has the advantage of being very precise, but all points in the map must fit into one UTM Tile. If points exceed a 100 km margin, the map can not be loaded. Mercator.h : WGS84 (for storage in .osm files) <-> Local Mercator as in liblanelet . Approximates the earth Geocentric.h : WGS84 <-> ECEF (wrapper of https://sourceforge.net/projects/geographiclib/). LocalCartesian.h : WGS84 <-> LocalCartesian (wrapper of https://sourceforge.net/projects/geographiclib/). This is similar to UTM; however, it properly treats elevation.","title":"lanelet2_projection"},{"location":"lanelet2_projection/#lanelet2-projection-module","text":"This module implements different projection functions as required by lanelet2_io .","title":"Lanelet2 Projection Module"},{"location":"lanelet2_projection/#need-for-projections","text":"As map data is commonly stored in WGS84 (lat/lon/ele) and lanelet2 operates on metrical data, there is a need for precise projection functions between the two. There are very good projection functions available, but they have to be used with the correct origin (close to the location of the map). Maps loaded with a wrong origin can easily be distorted by 40% and more. Angle calculations will be wrong as well. For more details, read here .","title":"Need for projections"},{"location":"lanelet2_projection/#supported-projections","text":"UTM.h : WGS84 (for storage in .osm files) <-> UTM (internal processing) (wrapper of https://sourceforge.net/projects/geographiclib/). This projection has the advantage of being very precise, but all points in the map must fit into one UTM Tile. If points exceed a 100 km margin, the map can not be loaded. Mercator.h : WGS84 (for storage in .osm files) <-> Local Mercator as in liblanelet . Approximates the earth Geocentric.h : WGS84 <-> ECEF (wrapper of https://sourceforge.net/projects/geographiclib/). LocalCartesian.h : WGS84 <-> LocalCartesian (wrapper of https://sourceforge.net/projects/geographiclib/). This is similar to UTM; however, it properly treats elevation.","title":"Supported Projections"},{"location":"lanelet2_python/","text":"Lanelet2 python Provides python bindings for Lanelet2 and its modules. Usage After building and sourcing you can do something like the follwoing in python(2): import lanelet2 map = lanelet2.io.load(\"myfile.osm\", lanelet2.io.Origin(49,8.4)) # Modify/Add attribute to all lanelets for elem in map.laneletLayer: if \"participant:vehicle\" in elem.attributes: elem.attributes[\"participant:vehicle\"] = \"no\" For more usage examples refer to our example package .","title":"lanelet2_python"},{"location":"lanelet2_python/#lanelet2-python","text":"Provides python bindings for Lanelet2 and its modules.","title":"Lanelet2 python"},{"location":"lanelet2_python/#usage","text":"After building and sourcing you can do something like the follwoing in python(2): import lanelet2 map = lanelet2.io.load(\"myfile.osm\", lanelet2.io.Origin(49,8.4)) # Modify/Add attribute to all lanelets for elem in map.laneletLayer: if \"participant:vehicle\" in elem.attributes: elem.attributes[\"participant:vehicle\"] = \"no\" For more usage examples refer to our example package .","title":"Usage"},{"location":"lanelet2_routing/","text":"Lanelet2 routing The routing module for lanelet2. For a short version of this you can also look at the presentation . If some images do not render correctly, please clone the repository and open the html file in your browser. This readme covers some basics. The API offers more than that. 1. Components and Vocabulary How to create a Routing Graph The needed components to create a routing graph are: Routing Cost Modules: * They generically determine the routing cost for travelling along a lanelet/area * Can be e.g. length, travel time * You can dynamically select between them when querying the routing graph * You can easily plug in your own routing cost calculation * Influences the prefered path Traffic Rules for a Specific Participant (see lanelet2_traffic_rules ) * Determines which lanelets/areas are passable * Influences the possible paths Lanelet Map: (see lanelet2_core ) * Map with Lanelets, Areas, Regulatory Elements, ... Relations Lanelets that are part of a routing graph can have relations to each other: The possible relations are: * left , right (reachable via lane change) * adjacent left , adjacent right (lanelets that are neighbours but not reachable via lane change) * succeeding (relation between two subsequent lanelets) * conflicting (intersecting lanelets/areas) * area (reachable area to lanelet/area relation) Route vs Path vs Sequence When querying data in the routing graph, you will come across the terms route , path and sequence . In contrast to a simple set of lanelets (data-wise a vector of lanelets), they have a special meaning and are data-wise different classes. A route means all the lanelets that can be used to a destination without driving a different road. They can be connected by a generic sequence of lane changes and successors. A path (LaneletPath or LaneletOrAreaPath) is an ordered list of Lanelets/Areas that lead to the destination. They can be connected by lane changes. A sequence (LaneletSequence) is a sequence of subsequent Lanelets that is not separated by a lane change (think of it as a lane ). It does not necessary lead to a destination, instead it ends when a lane change is required. In the example image, the lanelets A, D, B form a valid sequence (and also a valid path ), while the lanelets A, D, E are a valid path , but not a valid sequence . 2. Code Usage Create a Routing Graph using namespace lanelet; // Load a map LaneletMapPtr map = load(\"map.osm\", Origin({49, 8})); // origin has to be close to the map data in lat/lon coordinates // Initialize traffic rules TrafficRulesPtr trafficRules{TrafficRulesFactory::instance().create(Locations::Germany, Participants::Vehicle)}; // Optional: Initalize routing costs double laneChangeCost = 2; RoutingCostPtrs costPtrs{std::make_shared<RoutingCostDistance>(laneChangeCost)}; // Optional: Initialize config for routing graph: RoutingGraph::Configuration routingGraphConf; routingGraphConf.emplace(std::make_pair(RoutingGraph::ParticipantHeight, Attribute(\"2.\"))); // Create routing graph RoutingGraphPtr graph = RoutingGraph::build(map, trafficRules /*, costPtrs, routingGraphConf*/); The traffic rules object represents the view from which the map will be interpreted. Doing routing with vehicle traffic rules will yield different results than routing with e.g. bicycle traffic rules. Routing for bicycles might include lanelets that are not available to (motorized)vehicles and vice versa. The python interface works similarly: import lanelet2 map = lanelet2.io.load(\"map.osm\", lanelet2.io.Origin(49, 8)) trafficRules = lanelet2.traffic_rules.create(lanelet2.traffic_rules.Locations.Germany, lanelet2.traffic_rules.Participants.Vehicle) graph = lanelet2.routing.RoutingGraph(map, trafficRules) Get a shortest path Optional<routing::LaneletPath> shortestPath = graph->shortestPath(fromLanelet, toLanelet); Optional will be uninitialized (false) if there's no path there's also shortestPathWithVia in python: shortestPath = graph.shortestPath(fromLanelet, toLanelet) In python, shortestPath simply returns None if there is no path. Get and write a route Optional<Route> route = graph->getRoute(fromLanelet, toLanelet, routingCostId); if (route) { LaneletSubmapConstPtr routeMap = route->laneletSubmap(); write(\"route.osm\", *routeMap->laneletMap(), Origin({49, 8})); } Optional will be uninitialized (false) if there's no route Note that there is a semantic difference between a LaneletSubmap and a LaneletMap . While a LaneletSubmap only contains the things you explicitly added, the LaneletMap also contains all the things referred by them (the Points, Linestrings, things referred by RegulatoryElements). The LaneletSubmap in this case only contains the Lanelets of the route. But since this is not sufficient for writing, you need to transform it into a regular LaneletMap first. The written map will therefore not only contain the Lanelets but also their RegulatoryElements. If these RegulatoryElements contain other Lanelets, these Lanelets will be part of the written map as well, even if they are not on the route. in python: route = graph.getRoute(fromLanelet, toLanelet, routingCostId) if route: laneletSubmap = route.laneletSubmap() lanelet2.io.write(\"route.osm\", laneletSubmap.laneletMap(), lanelet2.io.Origin(49, 8))) Get a reachable set of lanelets double maxRoutingCost{100}; ConstLanelets reachableSet = graph->reachableSet(lanelet, maxRoutingCost, routingCostId); Left, Right, Following Lanelets // Get routable left lanelet if it exists Optional<ConstLanelet> left{graph->left(fromLanelet)}; // Get non-routable left lanelet if it exists Optional<ConstLanelet> adjacentLeft{graph->adjacentLeft(fromLanelet)}; // Get following lanelets ConstLanelets following{graph->following(fromLanelet)}; Also available: right , adjacentRight , lefts , rights , conflicting Alternatively: or queries that return relations: // Get relations to all left lanelets LaneletRelations leftRelations = graph->leftRelations( fromLanelet); There's leftRelations that returns a vector of pairs of LaneletRelations whereas RelationType can be 'left' or 'adjacentLeft' in this case More This is just a quick walkthrough. Advanced examples can be found in lanelet2_examples . 3. Export and Debugging Routing Graphs LaneletMap with Routing Information LaneletMapConstPtr debugLaneletMap = graph->getDebugLaneletMap(RoutingCostId(0)); write(std::string(\"routing_graph.osm\"), *debugLaneletMap); This one is best viewed in JOSM and using a custom map style css which is to be found in res/routing.mapcss . This gif shows, how to add a style to JOSM, except that one needs to press the + button in the configuration menu and specify the file. Most of the information is to be found in the attributes. The line strings that connect lanelets do have a direction. The name of the forth-direction is generally to be found left/above the line and the reverse relation right/under the string. DOT (GraphViz) and GraphML (xml-based) file export graph->exportGraphViz(\"~/graph.gv\"); graph->exportGraphML(\"~/graph.graphml\"); These can then be viewed with a graph viewer like Gephi . The downside compared to the laneletMap export is, that the lanelets aren't localized. 4. Routes Example route through Oststadtkreisel : Output of getDebugLaneletMap() function: Example Relational Queries on Routes: // Get left lanelet of example lanelet 'll' Optional<ConstLaneletRelation> left = route->leftRelation(ll); // Get conflicting lanelets of 'll' ConstLanelets conflicting = route->conflictingInRoute(ll); Note that a route just returns relations to lanelets that can be used to reach the goal. Other example queries: // Get underlying shortest path Optional<routing::LaneletPath> shortestPath = route->shortestPath(); // Get the full lane of a given lanelet 'll' LaneletSequence fullLane = route->fullLane(ll); // Get remaining lane of a given lanelet 'll' LaneletSequence remainingLane = route->remainingLane(ll); 5. Interconnect Routing Graphs of Different Participants A RoutingGraphContainer can be used to connect graphs of different participants to get information about conflicting lanelets. Create a RoutingGraphContainer std::vector<RoutingGraphPtr> graphs; graphs.emplace_back(vehicleGraphLaneletMap); graphs.emplace_back(pedestrianGraphLaneletMap); RoutingGraphContainer container(graphs); Example Queries The last parameter participantHeight is optional and decides whether conflicting lanelets are determined in 2D or 3D. Query for a single lanelet double heightClearance{4.}; // Height of the traffic participant // Query a single graph for conflicting lanelets size_t routingGraphId{0}; // E.g. 0 for the first graph ConstLanelets conflictingVehicle{container->conflictingInGraph(bridgeLanelet, routingGraphId, heightClearance)}; // Query all graphs for conflicting lanelets RoutingGraphContainer::ConflictingInGraphs conflicting{container->conflictingInGraphs(bridgeLanelet, heightClearance)}; Query for a Whole Route // Conflicting lanelets of a route in a single graph ConstLanelets conflictingVehicle{container->conflictingOfRouteInGraph(routePtr, routingGraphId)}; // Conflicting lanelets of a route in all graphs RoutingGraphContainer::ConflictingInGraphs result{container->conflictingOfRouteInGraphs(routePtr, heightClearance)};","title":"lanelet2_routing"},{"location":"lanelet2_routing/#lanelet2-routing","text":"The routing module for lanelet2. For a short version of this you can also look at the presentation . If some images do not render correctly, please clone the repository and open the html file in your browser. This readme covers some basics. The API offers more than that.","title":"Lanelet2 routing"},{"location":"lanelet2_routing/#1-components-and-vocabulary","text":"","title":"1. Components and Vocabulary"},{"location":"lanelet2_routing/#how-to-create-a-routing-graph","text":"The needed components to create a routing graph are: Routing Cost Modules: * They generically determine the routing cost for travelling along a lanelet/area * Can be e.g. length, travel time * You can dynamically select between them when querying the routing graph * You can easily plug in your own routing cost calculation * Influences the prefered path Traffic Rules for a Specific Participant (see lanelet2_traffic_rules ) * Determines which lanelets/areas are passable * Influences the possible paths Lanelet Map: (see lanelet2_core ) * Map with Lanelets, Areas, Regulatory Elements, ...","title":"How to create a Routing Graph"},{"location":"lanelet2_routing/#relations","text":"Lanelets that are part of a routing graph can have relations to each other: The possible relations are: * left , right (reachable via lane change) * adjacent left , adjacent right (lanelets that are neighbours but not reachable via lane change) * succeeding (relation between two subsequent lanelets) * conflicting (intersecting lanelets/areas) * area (reachable area to lanelet/area relation)","title":"Relations"},{"location":"lanelet2_routing/#route-vs-path-vs-sequence","text":"When querying data in the routing graph, you will come across the terms route , path and sequence . In contrast to a simple set of lanelets (data-wise a vector of lanelets), they have a special meaning and are data-wise different classes. A route means all the lanelets that can be used to a destination without driving a different road. They can be connected by a generic sequence of lane changes and successors. A path (LaneletPath or LaneletOrAreaPath) is an ordered list of Lanelets/Areas that lead to the destination. They can be connected by lane changes. A sequence (LaneletSequence) is a sequence of subsequent Lanelets that is not separated by a lane change (think of it as a lane ). It does not necessary lead to a destination, instead it ends when a lane change is required. In the example image, the lanelets A, D, B form a valid sequence (and also a valid path ), while the lanelets A, D, E are a valid path , but not a valid sequence .","title":"Route vs Path vs Sequence"},{"location":"lanelet2_routing/#2-code-usage","text":"","title":"2. Code Usage"},{"location":"lanelet2_routing/#create-a-routing-graph","text":"using namespace lanelet; // Load a map LaneletMapPtr map = load(\"map.osm\", Origin({49, 8})); // origin has to be close to the map data in lat/lon coordinates // Initialize traffic rules TrafficRulesPtr trafficRules{TrafficRulesFactory::instance().create(Locations::Germany, Participants::Vehicle)}; // Optional: Initalize routing costs double laneChangeCost = 2; RoutingCostPtrs costPtrs{std::make_shared<RoutingCostDistance>(laneChangeCost)}; // Optional: Initialize config for routing graph: RoutingGraph::Configuration routingGraphConf; routingGraphConf.emplace(std::make_pair(RoutingGraph::ParticipantHeight, Attribute(\"2.\"))); // Create routing graph RoutingGraphPtr graph = RoutingGraph::build(map, trafficRules /*, costPtrs, routingGraphConf*/); The traffic rules object represents the view from which the map will be interpreted. Doing routing with vehicle traffic rules will yield different results than routing with e.g. bicycle traffic rules. Routing for bicycles might include lanelets that are not available to (motorized)vehicles and vice versa. The python interface works similarly: import lanelet2 map = lanelet2.io.load(\"map.osm\", lanelet2.io.Origin(49, 8)) trafficRules = lanelet2.traffic_rules.create(lanelet2.traffic_rules.Locations.Germany, lanelet2.traffic_rules.Participants.Vehicle) graph = lanelet2.routing.RoutingGraph(map, trafficRules)","title":"Create a Routing Graph"},{"location":"lanelet2_routing/#get-a-shortest-path","text":"Optional<routing::LaneletPath> shortestPath = graph->shortestPath(fromLanelet, toLanelet); Optional will be uninitialized (false) if there's no path there's also shortestPathWithVia in python: shortestPath = graph.shortestPath(fromLanelet, toLanelet) In python, shortestPath simply returns None if there is no path.","title":"Get a shortest path"},{"location":"lanelet2_routing/#get-and-write-a-route","text":"Optional<Route> route = graph->getRoute(fromLanelet, toLanelet, routingCostId); if (route) { LaneletSubmapConstPtr routeMap = route->laneletSubmap(); write(\"route.osm\", *routeMap->laneletMap(), Origin({49, 8})); } Optional will be uninitialized (false) if there's no route Note that there is a semantic difference between a LaneletSubmap and a LaneletMap . While a LaneletSubmap only contains the things you explicitly added, the LaneletMap also contains all the things referred by them (the Points, Linestrings, things referred by RegulatoryElements). The LaneletSubmap in this case only contains the Lanelets of the route. But since this is not sufficient for writing, you need to transform it into a regular LaneletMap first. The written map will therefore not only contain the Lanelets but also their RegulatoryElements. If these RegulatoryElements contain other Lanelets, these Lanelets will be part of the written map as well, even if they are not on the route. in python: route = graph.getRoute(fromLanelet, toLanelet, routingCostId) if route: laneletSubmap = route.laneletSubmap() lanelet2.io.write(\"route.osm\", laneletSubmap.laneletMap(), lanelet2.io.Origin(49, 8)))","title":"Get and write a route"},{"location":"lanelet2_routing/#get-a-reachable-set-of-lanelets","text":"double maxRoutingCost{100}; ConstLanelets reachableSet = graph->reachableSet(lanelet, maxRoutingCost, routingCostId);","title":"Get a reachable set of lanelets"},{"location":"lanelet2_routing/#left-right-following-lanelets","text":"// Get routable left lanelet if it exists Optional<ConstLanelet> left{graph->left(fromLanelet)}; // Get non-routable left lanelet if it exists Optional<ConstLanelet> adjacentLeft{graph->adjacentLeft(fromLanelet)}; // Get following lanelets ConstLanelets following{graph->following(fromLanelet)}; Also available: right , adjacentRight , lefts , rights , conflicting Alternatively: or queries that return relations: // Get relations to all left lanelets LaneletRelations leftRelations = graph->leftRelations( fromLanelet); There's leftRelations that returns a vector of pairs of LaneletRelations whereas RelationType can be 'left' or 'adjacentLeft' in this case","title":"Left, Right, Following Lanelets"},{"location":"lanelet2_routing/#more","text":"This is just a quick walkthrough. Advanced examples can be found in lanelet2_examples .","title":"More"},{"location":"lanelet2_routing/#3-export-and-debugging-routing-graphs","text":"","title":"3. Export and Debugging Routing Graphs"},{"location":"lanelet2_routing/#laneletmap-with-routing-information","text":"LaneletMapConstPtr debugLaneletMap = graph->getDebugLaneletMap(RoutingCostId(0)); write(std::string(\"routing_graph.osm\"), *debugLaneletMap); This one is best viewed in JOSM and using a custom map style css which is to be found in res/routing.mapcss . This gif shows, how to add a style to JOSM, except that one needs to press the + button in the configuration menu and specify the file. Most of the information is to be found in the attributes. The line strings that connect lanelets do have a direction. The name of the forth-direction is generally to be found left/above the line and the reverse relation right/under the string.","title":"LaneletMap with Routing Information"},{"location":"lanelet2_routing/#dot-graphviz-and-graphml-xml-based-file-export","text":"graph->exportGraphViz(\"~/graph.gv\"); graph->exportGraphML(\"~/graph.graphml\"); These can then be viewed with a graph viewer like Gephi . The downside compared to the laneletMap export is, that the lanelets aren't localized.","title":"DOT (GraphViz) and GraphML (xml-based) file export"},{"location":"lanelet2_routing/#4-routes","text":"Example route through Oststadtkreisel : Output of getDebugLaneletMap() function:","title":"4. Routes"},{"location":"lanelet2_routing/#example-relational-queries-on-routes","text":"// Get left lanelet of example lanelet 'll' Optional<ConstLaneletRelation> left = route->leftRelation(ll); // Get conflicting lanelets of 'll' ConstLanelets conflicting = route->conflictingInRoute(ll); Note that a route just returns relations to lanelets that can be used to reach the goal.","title":"Example Relational Queries on Routes:"},{"location":"lanelet2_routing/#other-example-queries","text":"// Get underlying shortest path Optional<routing::LaneletPath> shortestPath = route->shortestPath(); // Get the full lane of a given lanelet 'll' LaneletSequence fullLane = route->fullLane(ll); // Get remaining lane of a given lanelet 'll' LaneletSequence remainingLane = route->remainingLane(ll);","title":"Other example queries:"},{"location":"lanelet2_routing/#5-interconnect-routing-graphs-of-different-participants","text":"A RoutingGraphContainer can be used to connect graphs of different participants to get information about conflicting lanelets.","title":"5. Interconnect Routing Graphs of Different Participants"},{"location":"lanelet2_routing/#create-a-routinggraphcontainer","text":"std::vector<RoutingGraphPtr> graphs; graphs.emplace_back(vehicleGraphLaneletMap); graphs.emplace_back(pedestrianGraphLaneletMap); RoutingGraphContainer container(graphs);","title":"Create a RoutingGraphContainer"},{"location":"lanelet2_routing/#example-queries","text":"The last parameter participantHeight is optional and decides whether conflicting lanelets are determined in 2D or 3D.","title":"Example Queries"},{"location":"lanelet2_routing/#query-for-a-single-lanelet","text":"double heightClearance{4.}; // Height of the traffic participant // Query a single graph for conflicting lanelets size_t routingGraphId{0}; // E.g. 0 for the first graph ConstLanelets conflictingVehicle{container->conflictingInGraph(bridgeLanelet, routingGraphId, heightClearance)}; // Query all graphs for conflicting lanelets RoutingGraphContainer::ConflictingInGraphs conflicting{container->conflictingInGraphs(bridgeLanelet, heightClearance)};","title":"Query for a single lanelet"},{"location":"lanelet2_routing/#query-for-a-whole-route","text":"// Conflicting lanelets of a route in a single graph ConstLanelets conflictingVehicle{container->conflictingOfRouteInGraph(routePtr, routingGraphId)}; // Conflicting lanelets of a route in all graphs RoutingGraphContainer::ConflictingInGraphs result{container->conflictingOfRouteInGraphs(routePtr, heightClearance)};","title":"Query for a Whole Route"},{"location":"lanelet2_traffic_rules/","text":"Lanelet2 Traffic Rules This package provides functionality for interpreting the traffic rules in a lanelet map depending on a country and a traffic participant. It contains functionality to determine right of way, speed limits and legally reachable lanelets for a certain participant. Usage #include <lanelet2_traffic_rules/TrafficRulesFactory.h> lanelet::traffic_rules::TrafficRulesPtr trafficRulesPtr = lanelet::traffic_rules::TrafficRulesFactory::create(lanelet::Locations::Germany, lanelet::Participants::Vehicle); bool passable = trafficRulesPtr->canPass(myLanelet); lanelet::traffic_rules::SpeedLimitInformation speedLimit = trafficRulesPtr->speedLimit(myLanelet); Structure This package offers the abstract TrafficRules class that is used as an interface to interpret the data in the map. It provides information whether a lanelet is usable/drivable, where lane changes are possible and what the speed limits are. Derived from this is the abstract GenericTrafficRules class that implements the traffic rules based on the tagging specification . This class can then be derived to create traffic rules for individual countries and participants. This is especially important for the speed limits and interpreting country specific traffic signs. After registering this class using RegisterTrafficRules , Lanelet2 is able to create instances of this traffic rule using the TrafficRuleFactory . Hierarchical Structure of Participants Some classes of participants, especially vehicles, follow a hierarchical structure. A traffic rule class that is registered for an upper level of this class is expected to handle all specializations for this class. For example if a TrafficRules implementation is registered for vehicle , it can also be instanciated for vehicle:car , but not vice versa. When lanelets/areas have tags for specialized participants, e.g. have \"participant:vehicle:car=no\", the TrafficRule class must handle this appropriately. If these tags are too specialized for an instance, the result should be as conservative as possible. This means that if a TrafficRule instance for vehicle finds a participants:vehicle:car=no and participants:vehicle:bus=yes , the lanelet is not passable. However if it was instanciated for vehicle:bus instead of just vehicle the lanelet would be reported as passable.","title":"lanelet2_traffic_rules"},{"location":"lanelet2_traffic_rules/#lanelet2-traffic-rules","text":"This package provides functionality for interpreting the traffic rules in a lanelet map depending on a country and a traffic participant. It contains functionality to determine right of way, speed limits and legally reachable lanelets for a certain participant.","title":"Lanelet2 Traffic Rules"},{"location":"lanelet2_traffic_rules/#usage","text":"#include <lanelet2_traffic_rules/TrafficRulesFactory.h> lanelet::traffic_rules::TrafficRulesPtr trafficRulesPtr = lanelet::traffic_rules::TrafficRulesFactory::create(lanelet::Locations::Germany, lanelet::Participants::Vehicle); bool passable = trafficRulesPtr->canPass(myLanelet); lanelet::traffic_rules::SpeedLimitInformation speedLimit = trafficRulesPtr->speedLimit(myLanelet);","title":"Usage"},{"location":"lanelet2_traffic_rules/#structure","text":"This package offers the abstract TrafficRules class that is used as an interface to interpret the data in the map. It provides information whether a lanelet is usable/drivable, where lane changes are possible and what the speed limits are. Derived from this is the abstract GenericTrafficRules class that implements the traffic rules based on the tagging specification . This class can then be derived to create traffic rules for individual countries and participants. This is especially important for the speed limits and interpreting country specific traffic signs. After registering this class using RegisterTrafficRules , Lanelet2 is able to create instances of this traffic rule using the TrafficRuleFactory .","title":"Structure"},{"location":"lanelet2_traffic_rules/#hierarchical-structure-of-participants","text":"Some classes of participants, especially vehicles, follow a hierarchical structure. A traffic rule class that is registered for an upper level of this class is expected to handle all specializations for this class. For example if a TrafficRules implementation is registered for vehicle , it can also be instanciated for vehicle:car , but not vice versa. When lanelets/areas have tags for specialized participants, e.g. have \"participant:vehicle:car=no\", the TrafficRule class must handle this appropriately. If these tags are too specialized for an instance, the result should be as conservative as possible. This means that if a TrafficRule instance for vehicle finds a participants:vehicle:car=no and participants:vehicle:bus=yes , the lanelet is not passable. However if it was instanciated for vehicle:bus instead of just vehicle the lanelet would be reported as passable.","title":"Hierarchical Structure of Participants"},{"location":"lanelet2_validation/","text":"Lanelet2 Validation Validation package for lanelet2. Runs checks on common mapping errors and reports them. Usage Building this package will create the program lanelet2_validate . To test a map, simply run lanelet2_validate <mymap> , or better lanelet2_validate <mymap> --lat <lat> --lon <lon> , where lat/lon is the origin of your map. The tool will output errors and warnings that were found in your map. For advanced usage, try lanelet2_validate --help . Adding Your Own Validators Before implementing your check, choose a suitable validator. There are three different types of validators: * Map validators validate the primitives in the map and search for obvious mapping issues (tags, positioning, etc.) * Traffic rule validators look for primitives that cannot be interpreted with the traffic rules chose by the user * Routing graph validators check for issues in the routing graph, such as isolated nodes. Validators should check for one single thing only. Better implement too much validators than too few. To implement a validator, inherit from one of the base classes BasicValidator.cpp , and implement its operator() and the name() function. The name should be in the format \" . \". Then in a *.cpp file, register your validator with one of the registry functions like this: namespace { // or RegisterTrafficRuleValidator or RegisterRoutingGraphValidator... validation::RegisterMapValidator<MyCheckClass> register; } // namespace","title":"lanelet2_validation"},{"location":"lanelet2_validation/#lanelet2-validation","text":"Validation package for lanelet2. Runs checks on common mapping errors and reports them.","title":"Lanelet2 Validation"},{"location":"lanelet2_validation/#usage","text":"Building this package will create the program lanelet2_validate . To test a map, simply run lanelet2_validate <mymap> , or better lanelet2_validate <mymap> --lat <lat> --lon <lon> , where lat/lon is the origin of your map. The tool will output errors and warnings that were found in your map. For advanced usage, try lanelet2_validate --help .","title":"Usage"},{"location":"lanelet2_validation/#adding-your-own-validators","text":"Before implementing your check, choose a suitable validator. There are three different types of validators: * Map validators validate the primitives in the map and search for obvious mapping issues (tags, positioning, etc.) * Traffic rule validators look for primitives that cannot be interpreted with the traffic rules chose by the user * Routing graph validators check for issues in the routing graph, such as isolated nodes. Validators should check for one single thing only. Better implement too much validators than too few. To implement a validator, inherit from one of the base classes BasicValidator.cpp , and implement its operator() and the name() function. The name should be in the format \" . \". Then in a *.cpp file, register your validator with one of the registry functions like this: namespace { // or RegisterTrafficRuleValidator or RegisterRoutingGraphValidator... validation::RegisterMapValidator<MyCheckClass> register; } // namespace","title":"Adding Your Own Validators"},{"location":"lanelet2_core/Architecture/","text":"Architecture This file describes the technical architecture of Lanelet2. For information on the representation of Lanelet2 and its primitives, please read first here . Principles Data sharing In Lanelet2, everything that has an ID is unique across the whole map. Because multiple primitives can reference the same element, it is not possible to duplicate/copy the information of a Lanelet primitive. If that was possible, modifying the information would leave the map in an invalid state, because other elements that reference it would not be notified of the change. To solve this issue, Lanelet2's primitive do not actually store data. Instead, they hold a pointer to the real, uncopyable data object. This means they only provide a view on the underlying map data. This means that Lanelet2 primitives can be copied without regret, because all copies still point to the same underlying data object. If the data is modified through one of the primtives, all other copies can observe the change. This results in some interesting properties. Firstly, primitives can be copied extremely fast, because only the pointer is copied, not the data. Secondly, this means that we can provide different views on the data. One example is that we can give you a 2D view and a 3D view on the data, e.g. a Point2d that returns x and y coordinates but not the z coordinate. You can convert this point back to Point3d without losing information, because in the underlying data, the z-coordinate was always there. Linestrings behave similar. A LineString3d returns Point3d , a LineString2d gives you Point2d . We can also easily invert Linestrings and Lanelets with this technique. An inverted Linestring simply returns the underlying data in reversed order. You will not even notice it is inverted, because it still behaves in the same way as a non-inverted one. The effort of creating the inverted Linestring is - you guessed it - just the effort of copying a pointer! Like this we can make sure that modifying the map is always consistent. All primitives will observe the change. However, there are two exceptions to this, and they are related to caching: The centerline of a Lanelet is calculated based on the left and right bound at the time it was first requested. If the points of a left or right bound were modified, the Lanelet does not notice the change and returns the outdated centerline. You have to reset the centerline of the Lanelet yourself. The second issue is within the LaneletMap container. It holds some precalculated tree structures to efficiently query closest points or usages of a point. If one of the points is modified, the query will still run on the old tree structure. So the general message is: When you plan to modify the map, know what you are doing! Composability Since Lanelet2's primitives, especially Lanelets represent an atomic section of the map, it is often important to compose these atomic parts together to create compound objects. These compound primitives behave in the same way as the primitives they are composed of, but internally access the primitive's data. This is also driven by the pointer-based concept introduced above: The compound objects simply hold a list of pointers instead of a single one. As an example, you can compose multiple Linestring3d to one CompoundLineString3d . It behaves like a single Linestring, gives you its size() in points and access to the individual points while still internally accessing the data of the actual Linestrings. You can also compose polygons from Linestrings, LaneletSet from Lanelets, and so on. Const correctness Since modifying the map can make cached data invalid, and since modifications affect the whole map, Lanelet2 offers some protection against unwanted modification. This is related to const correctness : If an object is passed to a function as const , not only the data of the object itself is immutable, but also the data derived from it and all the copies that you make. E.g., if a function accepts a Linestring as ConstLinestring3d , its data is guaranteed to be immutable. If you access a point of the Linestring, you get a ConstPoint3d , that allows you to access its data, but not modify it. It is not possible to convert a ConstPoint3d back to a Point3d . This means, if you call a function that accepts a const LineString3d or even a ConstLineString3d , it is guaranteed that your map data will not be modified. Modularity We are aware of the fact that roads can be very different in different countries and different places. Some things can be hard to squeeze into the typical map format. Also, the requirements on the map can be very different. To account for this, we tried to make Lanelet2 as flexible as possible by adding customization points where you can plugin your customized solution. Also the modularity of Lanelet2 aims to make it as simple as possible to add new functionality in the future. Part of the flexibility concept is that the tags that are used on objects can be extended without any limits. This way you can easily add more specific information to your maps that you are missing. New, custom regulatory elements can be added to account for difficult traffic situations. Also Lanelet2 can be extended for different countries and different road participants by adding new TrafficRules objects which are used by Lanelet2 to interpret the map data. New parsers and writers for new map formats can be added and registered while still using the same good old load / write function. Geometry calculations Lanelet2's objects are meant to be directly usable for geometry calculations. They are all registered with boost::geometry, meaning the follwing is easily possible: double d = boost::geometry::distance(laneletPoint1, laneletPoint2) . If laneletPoint1/2 is a 2D point, you will get the result in 2D, else in 3D. However, there are limitations to this that originate from the fact that the ConstCorrectness concept and boost::geometry do not play well with each other, because boost::geometry gets confused by the different point types used when things are used in a const and a non-const context. If you want to know more how to solve this problem and avoid pages and pages of compiler errors from boost's feared template code, read our Geometry Primer on this. Overview and Interaction If you don't know Lanelet2's basic primitives yet, better read here first! Here, we want to introduce the basic terms and objects that you will be confronted with when using Lanelet2 and how they interact: * Primitive any Lanelet2 primitive and their derivates ( Lanelet , ConstLanelet , LineString2d , etc) * LaneletMap a LaneletMap is the basic storage container for primitives. It is separated in layers, one for each primitive type and offers different ways to access its data (by a BoundingBox , by ID, by nearest point, etc). It does not provide routing functionality. * TrafficRules a traffic rules object interprets the map. E.g., it reports if a Lanelet isPassable , or if lane changes are possible between two Lanelets. A traffic rule object interprets the map from the perspective of one road participant type. A vehicle TrafficRule object will therefore give completely different results on a specific Lanelet than a pedestrian TrafficRule object. * RoutingCost these classes are used by the routing graph to determine costs when driving from one Lanelet/area to another one. It could be by travelled distance, by travel time but there are no limits for more advanced routing cost functions. You can also choose the cost of lane changes so that routes with few, preferably long lane changes are preferred. * RoutingGraph a routing graph is built from a LaneletMap , TrafficRules and RoutingCost objects. One routing graph is only for one single participant: The one that the TrafficRules belong to. With the routing graph, you can make all kinds of queries to determine where you or someone else can go/drive. * Route a route is something returned by the graph when you query a route from A to B. It contains a structure of all the Lanelets that you can use along the way with the lowest routing cost, including all possible lane changes. * LaneletPath or Path in general is a sequence of Lanelets returned by the RoutingGraph that are directly adjacent and have the lowest routing cost to the destination. \"Adjacent\" means that they can also be connected by a lane change, not only by following the Lanelet in a straight direction. * LaneletSequence a list of directly succeeding Lanelets that can be reached without lane changes. A LaneletSequence is the special case of a LaneletPath where no lane change is necessary. * Projector projectors are used by the IO module to convert between maps that store date in the WGS84 (lat/lon) format and the local coordinates used by Lanelet2. There are many different projections that all have different properties, so you should choose the one that fits best to you. If in doubt, use UTM.","title":"Architecture"},{"location":"lanelet2_core/Architecture/#architecture","text":"This file describes the technical architecture of Lanelet2. For information on the representation of Lanelet2 and its primitives, please read first here .","title":"Architecture"},{"location":"lanelet2_core/Architecture/#principles","text":"","title":"Principles"},{"location":"lanelet2_core/Architecture/#data-sharing","text":"In Lanelet2, everything that has an ID is unique across the whole map. Because multiple primitives can reference the same element, it is not possible to duplicate/copy the information of a Lanelet primitive. If that was possible, modifying the information would leave the map in an invalid state, because other elements that reference it would not be notified of the change. To solve this issue, Lanelet2's primitive do not actually store data. Instead, they hold a pointer to the real, uncopyable data object. This means they only provide a view on the underlying map data. This means that Lanelet2 primitives can be copied without regret, because all copies still point to the same underlying data object. If the data is modified through one of the primtives, all other copies can observe the change. This results in some interesting properties. Firstly, primitives can be copied extremely fast, because only the pointer is copied, not the data. Secondly, this means that we can provide different views on the data. One example is that we can give you a 2D view and a 3D view on the data, e.g. a Point2d that returns x and y coordinates but not the z coordinate. You can convert this point back to Point3d without losing information, because in the underlying data, the z-coordinate was always there. Linestrings behave similar. A LineString3d returns Point3d , a LineString2d gives you Point2d . We can also easily invert Linestrings and Lanelets with this technique. An inverted Linestring simply returns the underlying data in reversed order. You will not even notice it is inverted, because it still behaves in the same way as a non-inverted one. The effort of creating the inverted Linestring is - you guessed it - just the effort of copying a pointer! Like this we can make sure that modifying the map is always consistent. All primitives will observe the change. However, there are two exceptions to this, and they are related to caching: The centerline of a Lanelet is calculated based on the left and right bound at the time it was first requested. If the points of a left or right bound were modified, the Lanelet does not notice the change and returns the outdated centerline. You have to reset the centerline of the Lanelet yourself. The second issue is within the LaneletMap container. It holds some precalculated tree structures to efficiently query closest points or usages of a point. If one of the points is modified, the query will still run on the old tree structure. So the general message is: When you plan to modify the map, know what you are doing!","title":"Data sharing"},{"location":"lanelet2_core/Architecture/#composability","text":"Since Lanelet2's primitives, especially Lanelets represent an atomic section of the map, it is often important to compose these atomic parts together to create compound objects. These compound primitives behave in the same way as the primitives they are composed of, but internally access the primitive's data. This is also driven by the pointer-based concept introduced above: The compound objects simply hold a list of pointers instead of a single one. As an example, you can compose multiple Linestring3d to one CompoundLineString3d . It behaves like a single Linestring, gives you its size() in points and access to the individual points while still internally accessing the data of the actual Linestrings. You can also compose polygons from Linestrings, LaneletSet from Lanelets, and so on.","title":"Composability"},{"location":"lanelet2_core/Architecture/#const-correctness","text":"Since modifying the map can make cached data invalid, and since modifications affect the whole map, Lanelet2 offers some protection against unwanted modification. This is related to const correctness : If an object is passed to a function as const , not only the data of the object itself is immutable, but also the data derived from it and all the copies that you make. E.g., if a function accepts a Linestring as ConstLinestring3d , its data is guaranteed to be immutable. If you access a point of the Linestring, you get a ConstPoint3d , that allows you to access its data, but not modify it. It is not possible to convert a ConstPoint3d back to a Point3d . This means, if you call a function that accepts a const LineString3d or even a ConstLineString3d , it is guaranteed that your map data will not be modified.","title":"Const correctness"},{"location":"lanelet2_core/Architecture/#modularity","text":"We are aware of the fact that roads can be very different in different countries and different places. Some things can be hard to squeeze into the typical map format. Also, the requirements on the map can be very different. To account for this, we tried to make Lanelet2 as flexible as possible by adding customization points where you can plugin your customized solution. Also the modularity of Lanelet2 aims to make it as simple as possible to add new functionality in the future. Part of the flexibility concept is that the tags that are used on objects can be extended without any limits. This way you can easily add more specific information to your maps that you are missing. New, custom regulatory elements can be added to account for difficult traffic situations. Also Lanelet2 can be extended for different countries and different road participants by adding new TrafficRules objects which are used by Lanelet2 to interpret the map data. New parsers and writers for new map formats can be added and registered while still using the same good old load / write function.","title":"Modularity"},{"location":"lanelet2_core/Architecture/#geometry-calculations","text":"Lanelet2's objects are meant to be directly usable for geometry calculations. They are all registered with boost::geometry, meaning the follwing is easily possible: double d = boost::geometry::distance(laneletPoint1, laneletPoint2) . If laneletPoint1/2 is a 2D point, you will get the result in 2D, else in 3D. However, there are limitations to this that originate from the fact that the ConstCorrectness concept and boost::geometry do not play well with each other, because boost::geometry gets confused by the different point types used when things are used in a const and a non-const context. If you want to know more how to solve this problem and avoid pages and pages of compiler errors from boost's feared template code, read our Geometry Primer on this.","title":"Geometry calculations"},{"location":"lanelet2_core/Architecture/#overview-and-interaction","text":"If you don't know Lanelet2's basic primitives yet, better read here first! Here, we want to introduce the basic terms and objects that you will be confronted with when using Lanelet2 and how they interact: * Primitive any Lanelet2 primitive and their derivates ( Lanelet , ConstLanelet , LineString2d , etc) * LaneletMap a LaneletMap is the basic storage container for primitives. It is separated in layers, one for each primitive type and offers different ways to access its data (by a BoundingBox , by ID, by nearest point, etc). It does not provide routing functionality. * TrafficRules a traffic rules object interprets the map. E.g., it reports if a Lanelet isPassable , or if lane changes are possible between two Lanelets. A traffic rule object interprets the map from the perspective of one road participant type. A vehicle TrafficRule object will therefore give completely different results on a specific Lanelet than a pedestrian TrafficRule object. * RoutingCost these classes are used by the routing graph to determine costs when driving from one Lanelet/area to another one. It could be by travelled distance, by travel time but there are no limits for more advanced routing cost functions. You can also choose the cost of lane changes so that routes with few, preferably long lane changes are preferred. * RoutingGraph a routing graph is built from a LaneletMap , TrafficRules and RoutingCost objects. One routing graph is only for one single participant: The one that the TrafficRules belong to. With the routing graph, you can make all kinds of queries to determine where you or someone else can go/drive. * Route a route is something returned by the graph when you query a route from A to B. It contains a structure of all the Lanelets that you can use along the way with the lowest routing cost, including all possible lane changes. * LaneletPath or Path in general is a sequence of Lanelets returned by the RoutingGraph that are directly adjacent and have the lowest routing cost to the destination. \"Adjacent\" means that they can also be connected by a lane change, not only by following the Lanelet in a straight direction. * LaneletSequence a list of directly succeeding Lanelets that can be reached without lane changes. A LaneletSequence is the special case of a LaneletPath where no lane change is necessary. * Projector projectors are used by the IO module to convert between maps that store date in the WGS84 (lat/lon) format and the local coordinates used by Lanelet2. There are many different projections that all have different properties, so you should choose the one that fits best to you. If in doubt, use UTM.","title":"Overview and Interaction"},{"location":"lanelet2_core/GeometryPrimer/","text":"Geometry Calculations With Lanelet2 Lanelet2 primitives interface with Boost.Geometry . Boost.Geometry offers almost all common geometry calculations and is very fast. One downside is that not all algorithms work well with normal Lanelet2 primitives (see below). Another downside is that Boost.Geometry is compile-time heavy and is thus not included in the normal lanelet2 headers. To use geometry calculations, include the respective geometry header, e.g. geometry/LineString.h . Thanks to boost, all common geometry algorithms are available out of the box. E.g. you can compute distances between points, linestrings, polygons, etc in all combinations in (mostly) all dimensions. There are usually two different kinds of algorithms: The one that Boost implements (like distance ) and the one that Lanelet2 implements (mostly on top of Boost), like boundingBox2d . When using the first kind, you should read the lines below, while the second kind can be used without further reading. For a list of algorithms that are available, please refer too Boost's documentation or look through lanelet's geometry headers (or doxygen). All algorithms there have a small description. Using Lanelet Primitives in Boost.Geometry Lanelet2 offers every geometrical primitive in three flavors, each for 2D and 3D. Because they are just pointers to the actual data, they can be converted without actually copying data: * Mutable (e.g. LineString2d ): Are mutable, returned members are mutable (unless the object is const, then they are also immutable) * Const (e.g. ConstLineString2d ): These are immutable, returned members (e.g. points of linestring) are also immutable * Hybrid (e.g. ConstHybridLineString2d ): Also immutable, returned members are not lanelet primitives (e.g. BasicPoint2d ). If in doubt, use this one . Let us consider these types one by one. The first one ( mutable ) has the property that it behaves differently (i.e. returns different types) when used const or non-const . This is an issue for some of Boost.Geometry algorithms, because they sometimes accept const and sometimes non-const objects and therefore get the type wrong. Even if they get the type right, Boost is not fully compatible with the concept that copied primitives still refer to the same data and might therefore accidentally modify the wrong data. Therefore algorithms that modify the input (e.g. correct ) are possible, but there is no 100% guarantee they work as expected (across all versions of Boost). The const version does not have the risk of accidentally modifying the wrong data (because they are always immutable), however some algorithms that should not modify the data still try to instanciate templates in which the data can be modified. This results in longish compiler errors (and this might change from Boost version to Boost version). Algorithms that modify the input data (such as correct ) can not be used because of the constness. The hybrid version returns non-lanelet objects (BasicPoint2d/3d), which are fully compatible with Boost. This is the best solution for almost all geometry calculations. However, algorithms that mutate the primitive itself (such as correct ) are not possible because the hybrid versions themselves are immutable (no points can be deleted or added). In summary: Type For example Use for Boost.Geometry Mutable LineString2d Only for mutating algorithms, but use with care Const ConstLineString2d No Hybrid ConstHybridLineString2d Yes, safe to use if they compile Understanding Boost Geometry's Errors Boost geometry is known for outputting endless lines of compiler errors when used in the wrong way. Here are some hints to find out what you did wrong (sometimes you have to look closely for the actual error in many lines of instanciated templates). They are related to GCC's error messages, but other compilers will output similar stuff: * Something about \"no member named 'set' in boost::geometry::traits::access [...]: You used a const primitive (or you used a mutable primitive and Boost converted it into a const by a mistake). Try using the hybrid version. * Some error including \"NOT_IMPLEMENTED_FOR_THIS_POINT_TYPE\" together with some *no matching function for call to assertion failed\": This is a very generic error and the error message may be misleading. One reason could be that you forgot to include some lanelet2_core/geometry headers. Other reasons could be that you used the function on a primitive it was not implemented for (refer to Boosts documentation for that) or that it was not implemented for this particular dimension. Especially 3D operations are often not implemented in boost::geometry. * Something with \"You mixed matrices of different sizes\". This is actually an error from Eigen . It means you passed a BasicPoint3d where a BasicPoint2d was expected (or vice versa). * Something with \"no matching member function for call to '_init1'\", also from Eigen : You passed a wrong type where a BasicPoint2d/3d was expected. * Some error in boost::assert_dimension_equal : You passed a 2d primitive to Boost where a 3d primitive was expected (or vice versa).","title":"GeometryPrimer"},{"location":"lanelet2_core/GeometryPrimer/#geometry-calculations-with-lanelet2","text":"Lanelet2 primitives interface with Boost.Geometry . Boost.Geometry offers almost all common geometry calculations and is very fast. One downside is that not all algorithms work well with normal Lanelet2 primitives (see below). Another downside is that Boost.Geometry is compile-time heavy and is thus not included in the normal lanelet2 headers. To use geometry calculations, include the respective geometry header, e.g. geometry/LineString.h . Thanks to boost, all common geometry algorithms are available out of the box. E.g. you can compute distances between points, linestrings, polygons, etc in all combinations in (mostly) all dimensions. There are usually two different kinds of algorithms: The one that Boost implements (like distance ) and the one that Lanelet2 implements (mostly on top of Boost), like boundingBox2d . When using the first kind, you should read the lines below, while the second kind can be used without further reading. For a list of algorithms that are available, please refer too Boost's documentation or look through lanelet's geometry headers (or doxygen). All algorithms there have a small description.","title":"Geometry Calculations With Lanelet2"},{"location":"lanelet2_core/GeometryPrimer/#using-lanelet-primitives-in-boostgeometry","text":"Lanelet2 offers every geometrical primitive in three flavors, each for 2D and 3D. Because they are just pointers to the actual data, they can be converted without actually copying data: * Mutable (e.g. LineString2d ): Are mutable, returned members are mutable (unless the object is const, then they are also immutable) * Const (e.g. ConstLineString2d ): These are immutable, returned members (e.g. points of linestring) are also immutable * Hybrid (e.g. ConstHybridLineString2d ): Also immutable, returned members are not lanelet primitives (e.g. BasicPoint2d ). If in doubt, use this one . Let us consider these types one by one. The first one ( mutable ) has the property that it behaves differently (i.e. returns different types) when used const or non-const . This is an issue for some of Boost.Geometry algorithms, because they sometimes accept const and sometimes non-const objects and therefore get the type wrong. Even if they get the type right, Boost is not fully compatible with the concept that copied primitives still refer to the same data and might therefore accidentally modify the wrong data. Therefore algorithms that modify the input (e.g. correct ) are possible, but there is no 100% guarantee they work as expected (across all versions of Boost). The const version does not have the risk of accidentally modifying the wrong data (because they are always immutable), however some algorithms that should not modify the data still try to instanciate templates in which the data can be modified. This results in longish compiler errors (and this might change from Boost version to Boost version). Algorithms that modify the input data (such as correct ) can not be used because of the constness. The hybrid version returns non-lanelet objects (BasicPoint2d/3d), which are fully compatible with Boost. This is the best solution for almost all geometry calculations. However, algorithms that mutate the primitive itself (such as correct ) are not possible because the hybrid versions themselves are immutable (no points can be deleted or added). In summary: Type For example Use for Boost.Geometry Mutable LineString2d Only for mutating algorithms, but use with care Const ConstLineString2d No Hybrid ConstHybridLineString2d Yes, safe to use if they compile","title":"Using Lanelet Primitives in Boost.Geometry"},{"location":"lanelet2_core/GeometryPrimer/#understanding-boost-geometrys-errors","text":"Boost geometry is known for outputting endless lines of compiler errors when used in the wrong way. Here are some hints to find out what you did wrong (sometimes you have to look closely for the actual error in many lines of instanciated templates). They are related to GCC's error messages, but other compilers will output similar stuff: * Something about \"no member named 'set' in boost::geometry::traits::access [...]: You used a const primitive (or you used a mutable primitive and Boost converted it into a const by a mistake). Try using the hybrid version. * Some error including \"NOT_IMPLEMENTED_FOR_THIS_POINT_TYPE\" together with some *no matching function for call to assertion failed\": This is a very generic error and the error message may be misleading. One reason could be that you forgot to include some lanelet2_core/geometry headers. Other reasons could be that you used the function on a primitive it was not implemented for (refer to Boosts documentation for that) or that it was not implemented for this particular dimension. Especially 3D operations are often not implemented in boost::geometry. * Something with \"You mixed matrices of different sizes\". This is actually an error from Eigen . It means you passed a BasicPoint3d where a BasicPoint2d was expected (or vice versa). * Something with \"no matching member function for call to '_init1'\", also from Eigen : You passed a wrong type where a BasicPoint2d/3d was expected. * Some error in boost::assert_dimension_equal : You passed a 2d primitive to Boost where a 3d primitive was expected (or vice versa).","title":"Understanding Boost Geometry's Errors"},{"location":"lanelet2_core/Lanelet1Compability/","text":"Migration from Lanelet1 (liblanelet) Lanelet1, formerly called liblanelet can be found here: https://github.com/fzi-forschungszentrum-informatik/liblanelet The maps following the Lanelet2 specification can be loaded using the old implementation. They will load all lanelets without differing between lanelet types. Areas are ignored. Loading new maps in old lanelet1 implementation is a good approach for a seamless migration. (Early implementations were not able to load maps with node ids larger than 32bit integer range (used in mapping_example.osm ), but this was fixed in v1.2.) Note, that extended features introduced in v1.1 and v1.2 like rudimentary traffic light handling, parking places and event regions are not fully compatible with Lanelet2 map data. In the Lanelet2 map specification these were redesigned from scratch. If you create new maps and you are still using lanelet1 it is a good idea to use the validator of Lanelet2 to (roughly) validate that it is compatible with Lanelet2. New projection methods Lanelet1 had only one projection method: spherical mercator with a local reference point. This is implemented in Lanelet2 as basic method in Projection.h as SphericalMercatorProjector . Use this projection if you come from lanelet1 and want to have the same behavior. Lanelet2 also supports more precise projections. Consider switching to one of these as soon as your application allows it. See package lanelet2_projection for more details. Main differences a lanelet1 user should know Map format specification: * Traffic light handling, parking places and event regions have been redesigned/replaced. * Borders of lanelets now actually have a meaning and are used to infer lane change maneuvers. * Lanelet2 distinguishes between map representation and interpretation. Depending on the road user, the map is interpreted differently. * Lanelets can only have one single left and one single right bound (this is required for the lane change feature). * A new Area type has been introduced to handle places of undirected traffic (Parking lots, pedestrian walks, etc). Implementation: * The implementation has been completely redesigned without respect to backwards compatibility. Expect to have lots of code changes when migrating. But they are worth it! * Lanelet2 converts geographic coordinates to a local metric coordinate system when loading the map. This results in higher performance when working on the map data and allows more complex projection methods. * Maps can be safely modified, copied and saved. * LineStrip has been renamed to LineString. * The old LaneletMap has been divided into smaller software parts to make it more customizable and maintainable. Parts of it can be found in the RoutingGraph (holds the topology) and the new LaneletMap (only holds the primitives). * Primitives (such as points, linestrings and lanelets) have an actual identity and are shared across all things that use them. Modifying the point of one linestring modifies all other references to this point in other linestrings. * Lanelet2 primitives support 3D calculations and can be inverted or converted to 2d/3d without copying data. * Lanelet2 directly supports geometry calculations. * Lanelet2 is thoroughly tested and does not segfault when trying to copy a LaneletMap :wink:.","title":"Lanelet1Compability"},{"location":"lanelet2_core/Lanelet1Compability/#migration-from-lanelet1-liblanelet","text":"Lanelet1, formerly called liblanelet can be found here: https://github.com/fzi-forschungszentrum-informatik/liblanelet The maps following the Lanelet2 specification can be loaded using the old implementation. They will load all lanelets without differing between lanelet types. Areas are ignored. Loading new maps in old lanelet1 implementation is a good approach for a seamless migration. (Early implementations were not able to load maps with node ids larger than 32bit integer range (used in mapping_example.osm ), but this was fixed in v1.2.) Note, that extended features introduced in v1.1 and v1.2 like rudimentary traffic light handling, parking places and event regions are not fully compatible with Lanelet2 map data. In the Lanelet2 map specification these were redesigned from scratch. If you create new maps and you are still using lanelet1 it is a good idea to use the validator of Lanelet2 to (roughly) validate that it is compatible with Lanelet2.","title":"Migration from Lanelet1 (liblanelet)"},{"location":"lanelet2_core/Lanelet1Compability/#new-projection-methods","text":"Lanelet1 had only one projection method: spherical mercator with a local reference point. This is implemented in Lanelet2 as basic method in Projection.h as SphericalMercatorProjector . Use this projection if you come from lanelet1 and want to have the same behavior. Lanelet2 also supports more precise projections. Consider switching to one of these as soon as your application allows it. See package lanelet2_projection for more details.","title":"New projection methods"},{"location":"lanelet2_core/Lanelet1Compability/#main-differences-a-lanelet1-user-should-know","text":"Map format specification: * Traffic light handling, parking places and event regions have been redesigned/replaced. * Borders of lanelets now actually have a meaning and are used to infer lane change maneuvers. * Lanelet2 distinguishes between map representation and interpretation. Depending on the road user, the map is interpreted differently. * Lanelets can only have one single left and one single right bound (this is required for the lane change feature). * A new Area type has been introduced to handle places of undirected traffic (Parking lots, pedestrian walks, etc). Implementation: * The implementation has been completely redesigned without respect to backwards compatibility. Expect to have lots of code changes when migrating. But they are worth it! * Lanelet2 converts geographic coordinates to a local metric coordinate system when loading the map. This results in higher performance when working on the map data and allows more complex projection methods. * Maps can be safely modified, copied and saved. * LineStrip has been renamed to LineString. * The old LaneletMap has been divided into smaller software parts to make it more customizable and maintainable. Parts of it can be found in the RoutingGraph (holds the topology) and the new LaneletMap (only holds the primitives). * Primitives (such as points, linestrings and lanelets) have an actual identity and are shared across all things that use them. Modifying the point of one linestring modifies all other references to this point in other linestrings. * Lanelet2 primitives support 3D calculations and can be inverted or converted to 2d/3d without copying data. * Lanelet2 directly supports geometry calculations. * Lanelet2 is thoroughly tested and does not segfault when trying to copy a LaneletMap :wink:.","title":"Main differences a lanelet1 user should know"},{"location":"lanelet2_core/LaneletAndAreaTagging/","text":"Tagging Lanelets and Areas This page explains the general mapping scheme for Lanelets. The tags are used by Lanelet2 to infer information on the traffic rules. All Lanelets and areas must be \"self sustained\" which means that all traffic restrictions that apply to a Lanelet must be determined just by looking at the Lanelet. The following important informations have to be determinable: The driving direction (only for Lanelets, by default assumed to be one-directional) The road users that the Lanelet is intended to be used by (by default vehicles only) The speed limit (by default the maximum speed for urban regions) In Lanelet2 no tag is mandatory, but if you want your map to behave reasonably, you should make sure that at least the above listed items can be correctly inferred. Subtype and Location The subtype tag determines what the actual type of the Lanelet is. It is used to determine the participants that are allowed to use the Lanelet as well as partly to determine the speed limit in the absence of SpeedLimit regulatory elements. The location tag is used to distinguish between urban and nonurban regions which can (depending on the country) affect the speed limit. The subtype tag is not set, lane is assumed. If location is not set, urban is assumed. Note that speed limits can be mandatory or non-mandatory . Non-mandatory speed limits are only recommendations. The determined speed limit is the minimum of the actual speed limit and the average speed of a participant on this road type. If it was based on average speed, it is assumed to be non-mandatory. Note that the values in the following table are just the values inferred by default. The actual interpretation depends on the chosen TrafficRule object in lanelet2_traffic_rules . subtype location description Inferred Participants Speed limit road urban A part of a road in urban region All vehicles and bikes City speed limit road nonurban A part of a road in nonurban region All vehicles and bikes Nonurban speed limit highway urban A part of a highway in urban region All vehicles Urban highway limit highway nonurban A part of a highway in nonurban region All vehicles Nonurban highway limit play_street - A part of a play street Vehicles, bikes, pedestrians play street speed limit emergency_lane - Lane for emergency vehicles Emergency vehicles Average emergency vehicle speed bus_lane urban Lane for buses Bus, Emergency, Taxi City speed limit bus_lane nonurban Lane for buses Bus, Emergency, Taxi Nonurban speed limit bicycle_lane - A lane that is usable only for bikes Bikes Average bike speed exit urban Exit area of a house or garage that crosses the crosswalk Vehicles, bikes, pedestrians Urban speed limit walkway - A part of a way for pedestrians Pedestrians Average pedestrian walking speed shared_walkway - A way shared by bikes and pedestrians Bikes, Pedestrians Average bike/pedestrian speed crosswalk - A part of a crosswalk Pedestrians Average pedestrian walking speed stairs - Well ... stairs Pedestrians Average pedestrian walking speed Overriding Since the inferred information above might be incorrect in some situations, it can be overridden by explicitly specifying participants or speed limit. If one of the participants is set like this, the subtype and location tags are ignored and all other participants are assumed to be disallowed. The allowed participants then have to be set one by one. The following particiants can be used to define individual special situations. They are prefixed with the type of information they are supposed to override. Values are always yes or no : * vehicle (affects all \"motorized\" participants) OR * vehicle:car OR * vehicle:\u200bcar:electric * vehicle:\u200bcar:combustion * vehicle:bus * vehicle:truck * vehicle:motorcycle * vehicle:taxi * vehicle:emergency * pedestrian * bicycle To override the participant information, prefix the participants with participant: , e.g. participant:vehicle:car=yes . This would allow only cars on this Lanelet/area. The normal vehicle tag can not be combined with any vehicle:xxx tag. If one of the vehicle:xxx tags is defined, all other vehicle:xxx tags must be set individually. The speed limit can be overridden separately by using the follwing tags ( speed_limit must be set, speed_limit_mandatory is optional): * speed_limit (any velocity, preferably with unit, e.g. 5 km/h , no unit is inferred as km/h ) * speed_limit_mandatory (yes or no, default is yes) For an even finer overriding behaviour, use speed_limit:xxx and speed_limit_mandatory:xxx , where xxx is one of the participants from above. If the fine overriding is used and no match can be found for the current participant, speed_limit is returned. If it is not set, 0 km/h is returned. Note that the speed limit can be overriden by RegulatoryElements . The general rule of thumb should be to avoid the overriding mechanism where possible. The information can be transported much cleaner by either creating a new TrafficRule class that covers road types that we do not cover or by using RegulatoryElements . Example Consider a lanelet with the following tags: Tag value type lanelet subtype road location urban participant:vehicle:taxi yes participant:vehicle:bus yes participant:pedestrian yes one_way:pedestrian no Since overriding is used, the subtype/location combination is ignored when determining allowed participants. This means that only the following participants are allowed: Taxi, Bus, Pedestrian. Because the speed limit is not overridden, it could be determined (depending on the country) as 50 km/h (the speed limit for vehicles in cities) for taxis and buses and as non-mandatory 4km/h for pedestrians, since the average walking speed of a pedestrian is assumed to be 4 km/h which is smaller than 50 km/h. The one_way tag - see the section \"Direction\" below - allows pedestrians in both directions (which is generally a good idea). Other, Optional Tags road_name (the name of the road) road_surface (dirt, asphalt, concrete, ...) region: the ISO 3166-2 code for the country in which this Lanelet/area is situated. The traffic rules might check this tag to ensure they are working on the correct part of the map. Lanelet Specific All Lanelets have type=lanelet . If the tag is not present, it will be added when saving to .osm, because this is a requirement for writing from/to osm files. Note that the lane change restrictions are not inferred based on the Lanelet tags, but on the tags on the borders. See here for more info. Direction By default, Lanelets are one-directional. The direction is determined by the order in which the left and right bound is set. Whether a Lanelet is one- or bi-directional is determined by the one_way tag. If it is set to no , the Lanelet is bidirectional. The one_way tag can be further specialized to define the direction for different participants. This can be done by appending the type of the participant (as in Overriding), e.g. one_way:bicycle=no . This would mean that the Lanelet is one-directional for all participants, except bicycles. one_way and one_way:xxxx can not be used in combination. Pedestrians use Lanelets always bi-directional, unless overridden. Area Specific All areas have type=multipolygon (!) for compability reasons with the osm file format. type=area is possible too but will be overwritten when writing map data to an .osm file. More subtypes Additionally to the subtypes described above, other tags can be used to define the environment of a road: * parking * freespace (road area without a purpose) * vegetation * keepout * building * traffic_island These tags can be interpreted by special TrafficRule objects to determine the drivable space (e.g. for parking maneuvers or emergency situations).","title":"LaneletAndAreaTagging"},{"location":"lanelet2_core/LaneletAndAreaTagging/#tagging-lanelets-and-areas","text":"This page explains the general mapping scheme for Lanelets. The tags are used by Lanelet2 to infer information on the traffic rules. All Lanelets and areas must be \"self sustained\" which means that all traffic restrictions that apply to a Lanelet must be determined just by looking at the Lanelet. The following important informations have to be determinable: The driving direction (only for Lanelets, by default assumed to be one-directional) The road users that the Lanelet is intended to be used by (by default vehicles only) The speed limit (by default the maximum speed for urban regions) In Lanelet2 no tag is mandatory, but if you want your map to behave reasonably, you should make sure that at least the above listed items can be correctly inferred.","title":"Tagging Lanelets and Areas"},{"location":"lanelet2_core/LaneletAndAreaTagging/#subtype-and-location","text":"The subtype tag determines what the actual type of the Lanelet is. It is used to determine the participants that are allowed to use the Lanelet as well as partly to determine the speed limit in the absence of SpeedLimit regulatory elements. The location tag is used to distinguish between urban and nonurban regions which can (depending on the country) affect the speed limit. The subtype tag is not set, lane is assumed. If location is not set, urban is assumed. Note that speed limits can be mandatory or non-mandatory . Non-mandatory speed limits are only recommendations. The determined speed limit is the minimum of the actual speed limit and the average speed of a participant on this road type. If it was based on average speed, it is assumed to be non-mandatory. Note that the values in the following table are just the values inferred by default. The actual interpretation depends on the chosen TrafficRule object in lanelet2_traffic_rules . subtype location description Inferred Participants Speed limit road urban A part of a road in urban region All vehicles and bikes City speed limit road nonurban A part of a road in nonurban region All vehicles and bikes Nonurban speed limit highway urban A part of a highway in urban region All vehicles Urban highway limit highway nonurban A part of a highway in nonurban region All vehicles Nonurban highway limit play_street - A part of a play street Vehicles, bikes, pedestrians play street speed limit emergency_lane - Lane for emergency vehicles Emergency vehicles Average emergency vehicle speed bus_lane urban Lane for buses Bus, Emergency, Taxi City speed limit bus_lane nonurban Lane for buses Bus, Emergency, Taxi Nonurban speed limit bicycle_lane - A lane that is usable only for bikes Bikes Average bike speed exit urban Exit area of a house or garage that crosses the crosswalk Vehicles, bikes, pedestrians Urban speed limit walkway - A part of a way for pedestrians Pedestrians Average pedestrian walking speed shared_walkway - A way shared by bikes and pedestrians Bikes, Pedestrians Average bike/pedestrian speed crosswalk - A part of a crosswalk Pedestrians Average pedestrian walking speed stairs - Well ... stairs Pedestrians Average pedestrian walking speed","title":"Subtype and Location"},{"location":"lanelet2_core/LaneletAndAreaTagging/#overriding","text":"Since the inferred information above might be incorrect in some situations, it can be overridden by explicitly specifying participants or speed limit. If one of the participants is set like this, the subtype and location tags are ignored and all other participants are assumed to be disallowed. The allowed participants then have to be set one by one. The following particiants can be used to define individual special situations. They are prefixed with the type of information they are supposed to override. Values are always yes or no : * vehicle (affects all \"motorized\" participants) OR * vehicle:car OR * vehicle:\u200bcar:electric * vehicle:\u200bcar:combustion * vehicle:bus * vehicle:truck * vehicle:motorcycle * vehicle:taxi * vehicle:emergency * pedestrian * bicycle To override the participant information, prefix the participants with participant: , e.g. participant:vehicle:car=yes . This would allow only cars on this Lanelet/area. The normal vehicle tag can not be combined with any vehicle:xxx tag. If one of the vehicle:xxx tags is defined, all other vehicle:xxx tags must be set individually. The speed limit can be overridden separately by using the follwing tags ( speed_limit must be set, speed_limit_mandatory is optional): * speed_limit (any velocity, preferably with unit, e.g. 5 km/h , no unit is inferred as km/h ) * speed_limit_mandatory (yes or no, default is yes) For an even finer overriding behaviour, use speed_limit:xxx and speed_limit_mandatory:xxx , where xxx is one of the participants from above. If the fine overriding is used and no match can be found for the current participant, speed_limit is returned. If it is not set, 0 km/h is returned. Note that the speed limit can be overriden by RegulatoryElements . The general rule of thumb should be to avoid the overriding mechanism where possible. The information can be transported much cleaner by either creating a new TrafficRule class that covers road types that we do not cover or by using RegulatoryElements .","title":"Overriding"},{"location":"lanelet2_core/LaneletAndAreaTagging/#example","text":"Consider a lanelet with the following tags: Tag value type lanelet subtype road location urban participant:vehicle:taxi yes participant:vehicle:bus yes participant:pedestrian yes one_way:pedestrian no Since overriding is used, the subtype/location combination is ignored when determining allowed participants. This means that only the following participants are allowed: Taxi, Bus, Pedestrian. Because the speed limit is not overridden, it could be determined (depending on the country) as 50 km/h (the speed limit for vehicles in cities) for taxis and buses and as non-mandatory 4km/h for pedestrians, since the average walking speed of a pedestrian is assumed to be 4 km/h which is smaller than 50 km/h. The one_way tag - see the section \"Direction\" below - allows pedestrians in both directions (which is generally a good idea).","title":"Example"},{"location":"lanelet2_core/LaneletAndAreaTagging/#other-optional-tags","text":"road_name (the name of the road) road_surface (dirt, asphalt, concrete, ...) region: the ISO 3166-2 code for the country in which this Lanelet/area is situated. The traffic rules might check this tag to ensure they are working on the correct part of the map.","title":"Other, Optional Tags"},{"location":"lanelet2_core/LaneletAndAreaTagging/#lanelet-specific","text":"All Lanelets have type=lanelet . If the tag is not present, it will be added when saving to .osm, because this is a requirement for writing from/to osm files. Note that the lane change restrictions are not inferred based on the Lanelet tags, but on the tags on the borders. See here for more info.","title":"Lanelet Specific"},{"location":"lanelet2_core/LaneletAndAreaTagging/#direction","text":"By default, Lanelets are one-directional. The direction is determined by the order in which the left and right bound is set. Whether a Lanelet is one- or bi-directional is determined by the one_way tag. If it is set to no , the Lanelet is bidirectional. The one_way tag can be further specialized to define the direction for different participants. This can be done by appending the type of the participant (as in Overriding), e.g. one_way:bicycle=no . This would mean that the Lanelet is one-directional for all participants, except bicycles. one_way and one_way:xxxx can not be used in combination. Pedestrians use Lanelets always bi-directional, unless overridden.","title":"Direction"},{"location":"lanelet2_core/LaneletAndAreaTagging/#area-specific","text":"All areas have type=multipolygon (!) for compability reasons with the osm file format. type=area is possible too but will be overwritten when writing map data to an .osm file.","title":"Area Specific"},{"location":"lanelet2_core/LaneletAndAreaTagging/#more-subtypes","text":"Additionally to the subtypes described above, other tags can be used to define the environment of a road: * parking * freespace (road area without a purpose) * vegetation * keepout * building * traffic_island These tags can be interpreted by special TrafficRule objects to determine the drivable space (e.g. for parking maneuvers or emergency situations).","title":"More subtypes"},{"location":"lanelet2_core/LaneletPrimitives/","text":"Lanelet Primitives Lanelet2 divides the world into a hierarchical structure of six different primitives: Points, Linestrings, polygons, Lanelets, Areas and regulatory elements. This article focuses on how the primitives are meant to be used, what properties they have and how they are meant to be used. For the technical side, please refer to the architecture page. Primitives All primitives have in common that they have a unique ID and attributes in form of key/value (or tag/value) pairs. There is generally no limit on what tags can be used, but some tags convey a special meaning. Also, tags that are common on Lanelet primitives are internally stored in a structure that allows for a more efficient access than custom tags. Tags are always lowercase and underscored. Some values have a special meaning, e.g. \"yes\" and \"no\" which are convertible to bool (yes->true, no->false). Some tags are used across all primitives: * type , denotes the category that a primitive belongs to. E.g. curbstone , traffic_sign or line_thin for a road marking. * subtype is used to further distinct the type. E.g. low to mark a passable curbstone or dashed to mark a dashed road marking * no_issue (yes/no): Suppresses warnings on this primitive reported by lanelet2_validation if yes . Points A point consists of an ID, a 3d coordinate and attributes. The ID must be unique to the point. Points are no meaningful objects in Lanelet2 per se. Points are only meaningful together with other objects in Lanelet2. The only situation where individual points are important is when tagging start and end points of a dashed line marking. Coordinate System Lanelet2 assumes that maps are layed out in the x-y plane. Since the road geometry tends to be flat, that gives the z-Coordinate a less important meaning than the other coordinates. Points can therefore straightforwardly be converted to a 2D point where the z-Coordinate is ignored. Still, 3D information is important when roads overlap so that it can be determined if two roads are actually intersecting or just crossing each other at a different height. When determining height information, it is generally assumed that the heigt is metric and with respect to WGS84 (i.e. the distance to the earth ellipsoid). For more details on geometry calculation, see here . It is still possible to follow a \"2.5D\"-Approach so that the height is generally 0 and only deviates to distinguish between bridges or tunnels. This approach might require configuring the routing graph differently, so that a height distance of 1 (meaning a new layer) is not wrongly interpreted as 1 m (this would be interpreted as two conflicting lanes). Linestrings Linestrings (also known as polylines or formerly linestrips) are defined by an ordered list of points with linear interpolation in between. They are the basic building block of a Lanelet map and used for any phisically observable part of the map. Linestrings must consist of at least one point to be valid and must not self-intersect. They must not contain points repeatedly (i.e. p1->p2->p2->p3 is not allowed). Linestrings must always have a type so that their purpose can be determined. The tags used to define the individual Linestrings are explained here . Polygon Polygons are very similar to Linestrings, but form an Area. It is implicitly assumed that the first and the last point of the polygon are connected to close the shape. Polygons, are rarely used to transport mapping information (except for e.g. traffic signs). Instead, they often serve as a means to add customized information about an area to the map (e.g. a region of interest). Lanelet A Lanelet represents one atomic section of a lane. Atomic means that along a Lanelet, traffic rules (including possible lane changes to other Lanelets) do not change. A Lanelet consists of exactly one left and exactly one right Linestring. Together they form the drivable area of the Lanelet. It is required that the Linestrings point into the same direction. That can mean that for two neighbouring, opposing Lanelets one of them has to hold an inverted Linestring as its border. When loading map data from osm, the library will do the alignment for you. If possible, the bounds should have a physical motivation (i.e. reference actual markings, curbstones, etc). The type of the boundary is used by the library to determine if lane changes are possible here. Lanelets may have an additional centerline to guide the vehicle. This centerline must be within the area formed by the left and right bound and must not touch the boundaries. If no centerline is given, the library will calculate it for you. By default, Lanelets are one-directional. Only if they are tagged as bidirectional, they are treated as such. Adjacent Lanelets have to share the same endpoints so that the Lanelet2 can determine their status of being adjacent. Lanelets can also diverge when two or more Lanelets are successors of a Lanelet. Lanelets that are reachable by a lane change must share one of their borders. A Lanelet can reference regulatory elements that represent traffic rules that apply to the Lanelet. Multiple Lanelets can reference the same regulatory element. It must always be possible to determine the current speed limit of the Lanelet directly from the Lanelet. This can either be done by referencing a SpeedLimit regulatory element or by tagging the location of the Lanelet. In this case the maximum speed for the type of road is assumed (e.g. max 50kph if the location is a german city). It must also be possible to determine the participants that are able to use the Lanelet. For more details on the exact tags of a Lanelet, please read here . Area An Area has similar properties like a Lanelet, but instead of representing directed traffic from entry to exit, an Area represents undirected traffic within its surface. An Area can have multiple entry and exit points. A typical example of an Area would be squares that are used by pedestrians or parking lots and emergency lanes for vehicles. Similar to Lanelets, traffic rules must not change on the areas. Geometrically, an Area is represented by an ordered list of Linestrings that together form the shape of the Area in clockwise orientation. Areas must share exactly one Linestring with another Area to be considered adajacent. For Lanelets they either have to share one Linestring (when the Lanelet is parallel to the Area) or the endpoints of the Lanelet are also the endpoints of one of the Linestrings of the Area (when the Lanelet leads into the Area). The actual area value of a Area must not be zero and the bounds must not self-intersect. The type of the shared boundary determines whether it is possible to pass from/to an Area. Areas can also have holes , i.e. parts of the Area that are not acessible. It is not allowed that another Lanelet or Area is within the hole of a bigger Area. In this case, the \"outer\" Area has to be split in two parts along the hole. Holes are represented similar to the outer bound: each by an ordered list of Linestrings that together form the shape of the hole. The points must be in counter-clockwise order. Tags that are applicable to Lanelets also apply to Areas (where it makes sense). See here for more. Similarly to Lanelets, Areas can refer to regulatory elements. Furthermore, it must be possible to determine the purpose of the Area as well as by which participants it is usable. Regulatory Elements Regulatory elements are a generic way to express traffic rules. They are referenced by Lanelets or areas for which they apply. In general, regulatory elements consist of tags that generally express the type of the rule (i.e. a traffic light regulatory element) and specific information about the observable things that have a certain role for this rule (e.g. the traffic light itself and the stop line). Other types of regulatory elements are right of way and traffic sign regulatory elements. The list is not closed at all, it is up to you to plug in more regulatory elements when necessary. For more information how to tag the build-in regulatory elements, please read on here .","title":"LaneletPrimitives"},{"location":"lanelet2_core/LaneletPrimitives/#lanelet-primitives","text":"Lanelet2 divides the world into a hierarchical structure of six different primitives: Points, Linestrings, polygons, Lanelets, Areas and regulatory elements. This article focuses on how the primitives are meant to be used, what properties they have and how they are meant to be used. For the technical side, please refer to the architecture page.","title":"Lanelet Primitives"},{"location":"lanelet2_core/LaneletPrimitives/#primitives","text":"All primitives have in common that they have a unique ID and attributes in form of key/value (or tag/value) pairs. There is generally no limit on what tags can be used, but some tags convey a special meaning. Also, tags that are common on Lanelet primitives are internally stored in a structure that allows for a more efficient access than custom tags. Tags are always lowercase and underscored. Some values have a special meaning, e.g. \"yes\" and \"no\" which are convertible to bool (yes->true, no->false). Some tags are used across all primitives: * type , denotes the category that a primitive belongs to. E.g. curbstone , traffic_sign or line_thin for a road marking. * subtype is used to further distinct the type. E.g. low to mark a passable curbstone or dashed to mark a dashed road marking * no_issue (yes/no): Suppresses warnings on this primitive reported by lanelet2_validation if yes .","title":"Primitives"},{"location":"lanelet2_core/LaneletPrimitives/#points","text":"A point consists of an ID, a 3d coordinate and attributes. The ID must be unique to the point. Points are no meaningful objects in Lanelet2 per se. Points are only meaningful together with other objects in Lanelet2. The only situation where individual points are important is when tagging start and end points of a dashed line marking.","title":"Points"},{"location":"lanelet2_core/LaneletPrimitives/#coordinate-system","text":"Lanelet2 assumes that maps are layed out in the x-y plane. Since the road geometry tends to be flat, that gives the z-Coordinate a less important meaning than the other coordinates. Points can therefore straightforwardly be converted to a 2D point where the z-Coordinate is ignored. Still, 3D information is important when roads overlap so that it can be determined if two roads are actually intersecting or just crossing each other at a different height. When determining height information, it is generally assumed that the heigt is metric and with respect to WGS84 (i.e. the distance to the earth ellipsoid). For more details on geometry calculation, see here . It is still possible to follow a \"2.5D\"-Approach so that the height is generally 0 and only deviates to distinguish between bridges or tunnels. This approach might require configuring the routing graph differently, so that a height distance of 1 (meaning a new layer) is not wrongly interpreted as 1 m (this would be interpreted as two conflicting lanes).","title":"Coordinate System"},{"location":"lanelet2_core/LaneletPrimitives/#linestrings","text":"Linestrings (also known as polylines or formerly linestrips) are defined by an ordered list of points with linear interpolation in between. They are the basic building block of a Lanelet map and used for any phisically observable part of the map. Linestrings must consist of at least one point to be valid and must not self-intersect. They must not contain points repeatedly (i.e. p1->p2->p2->p3 is not allowed). Linestrings must always have a type so that their purpose can be determined. The tags used to define the individual Linestrings are explained here .","title":"Linestrings"},{"location":"lanelet2_core/LaneletPrimitives/#polygon","text":"Polygons are very similar to Linestrings, but form an Area. It is implicitly assumed that the first and the last point of the polygon are connected to close the shape. Polygons, are rarely used to transport mapping information (except for e.g. traffic signs). Instead, they often serve as a means to add customized information about an area to the map (e.g. a region of interest).","title":"Polygon"},{"location":"lanelet2_core/LaneletPrimitives/#lanelet","text":"A Lanelet represents one atomic section of a lane. Atomic means that along a Lanelet, traffic rules (including possible lane changes to other Lanelets) do not change. A Lanelet consists of exactly one left and exactly one right Linestring. Together they form the drivable area of the Lanelet. It is required that the Linestrings point into the same direction. That can mean that for two neighbouring, opposing Lanelets one of them has to hold an inverted Linestring as its border. When loading map data from osm, the library will do the alignment for you. If possible, the bounds should have a physical motivation (i.e. reference actual markings, curbstones, etc). The type of the boundary is used by the library to determine if lane changes are possible here. Lanelets may have an additional centerline to guide the vehicle. This centerline must be within the area formed by the left and right bound and must not touch the boundaries. If no centerline is given, the library will calculate it for you. By default, Lanelets are one-directional. Only if they are tagged as bidirectional, they are treated as such. Adjacent Lanelets have to share the same endpoints so that the Lanelet2 can determine their status of being adjacent. Lanelets can also diverge when two or more Lanelets are successors of a Lanelet. Lanelets that are reachable by a lane change must share one of their borders. A Lanelet can reference regulatory elements that represent traffic rules that apply to the Lanelet. Multiple Lanelets can reference the same regulatory element. It must always be possible to determine the current speed limit of the Lanelet directly from the Lanelet. This can either be done by referencing a SpeedLimit regulatory element or by tagging the location of the Lanelet. In this case the maximum speed for the type of road is assumed (e.g. max 50kph if the location is a german city). It must also be possible to determine the participants that are able to use the Lanelet. For more details on the exact tags of a Lanelet, please read here .","title":"Lanelet"},{"location":"lanelet2_core/LaneletPrimitives/#area","text":"An Area has similar properties like a Lanelet, but instead of representing directed traffic from entry to exit, an Area represents undirected traffic within its surface. An Area can have multiple entry and exit points. A typical example of an Area would be squares that are used by pedestrians or parking lots and emergency lanes for vehicles. Similar to Lanelets, traffic rules must not change on the areas. Geometrically, an Area is represented by an ordered list of Linestrings that together form the shape of the Area in clockwise orientation. Areas must share exactly one Linestring with another Area to be considered adajacent. For Lanelets they either have to share one Linestring (when the Lanelet is parallel to the Area) or the endpoints of the Lanelet are also the endpoints of one of the Linestrings of the Area (when the Lanelet leads into the Area). The actual area value of a Area must not be zero and the bounds must not self-intersect. The type of the shared boundary determines whether it is possible to pass from/to an Area. Areas can also have holes , i.e. parts of the Area that are not acessible. It is not allowed that another Lanelet or Area is within the hole of a bigger Area. In this case, the \"outer\" Area has to be split in two parts along the hole. Holes are represented similar to the outer bound: each by an ordered list of Linestrings that together form the shape of the hole. The points must be in counter-clockwise order. Tags that are applicable to Lanelets also apply to Areas (where it makes sense). See here for more. Similarly to Lanelets, Areas can refer to regulatory elements. Furthermore, it must be possible to determine the purpose of the Area as well as by which participants it is usable.","title":"Area"},{"location":"lanelet2_core/LaneletPrimitives/#regulatory-elements","text":"Regulatory elements are a generic way to express traffic rules. They are referenced by Lanelets or areas for which they apply. In general, regulatory elements consist of tags that generally express the type of the rule (i.e. a traffic light regulatory element) and specific information about the observable things that have a certain role for this rule (e.g. the traffic light itself and the stop line). Other types of regulatory elements are right of way and traffic sign regulatory elements. The list is not closed at all, it is up to you to plug in more regulatory elements when necessary. For more information how to tag the build-in regulatory elements, please read on here .","title":"Regulatory Elements"},{"location":"lanelet2_core/LinestringTagging/","text":"Tagging Linestrings This page tells you about the general tags that you should use to annotate your map. Note: All tags are always lowercase. In general there are three different context in which linestrings are used: As lanelet/area boundary, as a Symbol on the road or as traffic sign/light. Linestrings are generally characterized by their centerline. As Lane Boundary Tagging linestrings as lane boundary correctly is important, because Lanelet2 uses the type to determine possible lane changes. If Lanelet2 cannot determine the type, Lanelet2 will assume that lane changes are not possible. Here is a list of the most important ones: type subtype description lane change? line_thin solid a solid lane marking no line_thin solid_solid a double solid lane marking no line_thin dashed a dashed lane marking yes line_thin dashed_solid a marking that is dashed on the left and solid on the right left->right: yes line_thin solid_dashed the other way around right->left: yes line_thick same as above for thin curbstone high a curbstone that is to high for a vehicle to drive over no curbstone low curb that is low and can be driven for a vehicle no virtual - a non-physical lane boundary, intended mainly for intersections no road_border - the end of the road. no Notice the difference between curbstone and road_border: A road border indicates the end of potentially passable area (e.g. start of vegetation) while a curbstone means that there is passable space (e.g. sidewalk) on the other side of the curb. There are much more tags (all imply lane changing is not possible): * guard_rail * wall * fence * zebra_marking (lanelets for pedestrians) * pedestrian_marking (lines on pedestrian crossings) * bike_marking (i.e. dashed line for bikes) * keepout * virtual * jersey_barrier * gate * door * rail (trains...) Feel free to \"invent\" new types if these do not satisfy your needs, but be aware that future parts of Lanelet2 might make use of the tags mentioned here (e.g. to precisely predict participants) and will fail to interpret custom types. Lane Change If you are unhappy with the types derived by default, you can overwrite it with these tags: * lane_change=yes (lane change in both directions possible) OR * lane_change:left= , lane_change:right= . Both pairs have to be set if this is used. More, Optional Tags width with of the line (in m). The linestring then represents the centerline of the object. height height of line (in m). The linestring then represents the lower outline/lowest edge of the object. temporary to indicate lines from construction sites (yes/no). color of the lane marking. White is the default. Individual Dashes Since dashed lines are represented by a full connecting line and not as individual dashes, the information about the position of the dashes is lost. To keep the information, individual points that mark the start and end points of the linestring can be tagged. The type tag is used for that. type=begin marks the begin of the dash (in the orientation of the linestring), type=end marks the end. Other values can be used for other types: * pole (to mark the position of individual poles on guardrails or fences) * dot (to mark dots that form line markings) Symbols There can be many different symbols so the selection here is of course incomplete. Symbols can be relevant for some traffic rules Arrows have type=\"arrow\" and a subtype for the direction: subtype: * left * right * straight * straight_left * straight_right * left_right Other types: * stop_line * yield_line * zig-zag * lift_gate * bump * 30/50/70 (for speed limits on the road) The symbol can be represented either by its outline or by its centerline. If it is represented by the centerline, the linestring must only contain two points to avoid confusion with the outline. Traffic Signs Traffic signs all have type=traffic_sign . Additionally, they have a \"subtype\"-tag that contains the actual type of the traffic sign. This subtype is encoded as ISO 3166 region code + traffic sign number (e.g. subtype=de206 for a German stop sign or subtype=usR1-1 for a US stop sign ). Traffic signs can be represented either by their outline (as polygon) or by a linestring where the first point is the left edge of the sign and the last point is the right edge of the sign. Optionally the height tag can be used to encode the size of the sign in z (not the height above ground, use the z-coordinate for that). The linestring marks the lower edge of the sign. Traffic Lights Traffic signs have type=traffic_light . Similar to traffic signs, they can be represented either by a polygon or a linestring. The subtype tag can be used to add further information on the traffic light: * red_yellow_green * red_yellow * red * etc.","title":"LinestringTagging"},{"location":"lanelet2_core/LinestringTagging/#tagging-linestrings","text":"This page tells you about the general tags that you should use to annotate your map. Note: All tags are always lowercase. In general there are three different context in which linestrings are used: As lanelet/area boundary, as a Symbol on the road or as traffic sign/light. Linestrings are generally characterized by their centerline.","title":"Tagging Linestrings"},{"location":"lanelet2_core/LinestringTagging/#as-lane-boundary","text":"Tagging linestrings as lane boundary correctly is important, because Lanelet2 uses the type to determine possible lane changes. If Lanelet2 cannot determine the type, Lanelet2 will assume that lane changes are not possible. Here is a list of the most important ones: type subtype description lane change? line_thin solid a solid lane marking no line_thin solid_solid a double solid lane marking no line_thin dashed a dashed lane marking yes line_thin dashed_solid a marking that is dashed on the left and solid on the right left->right: yes line_thin solid_dashed the other way around right->left: yes line_thick same as above for thin curbstone high a curbstone that is to high for a vehicle to drive over no curbstone low curb that is low and can be driven for a vehicle no virtual - a non-physical lane boundary, intended mainly for intersections no road_border - the end of the road. no Notice the difference between curbstone and road_border: A road border indicates the end of potentially passable area (e.g. start of vegetation) while a curbstone means that there is passable space (e.g. sidewalk) on the other side of the curb. There are much more tags (all imply lane changing is not possible): * guard_rail * wall * fence * zebra_marking (lanelets for pedestrians) * pedestrian_marking (lines on pedestrian crossings) * bike_marking (i.e. dashed line for bikes) * keepout * virtual * jersey_barrier * gate * door * rail (trains...) Feel free to \"invent\" new types if these do not satisfy your needs, but be aware that future parts of Lanelet2 might make use of the tags mentioned here (e.g. to precisely predict participants) and will fail to interpret custom types.","title":"As Lane Boundary"},{"location":"lanelet2_core/LinestringTagging/#lane-change","text":"If you are unhappy with the types derived by default, you can overwrite it with these tags: * lane_change=yes (lane change in both directions possible) OR * lane_change:left= , lane_change:right= . Both pairs have to be set if this is used.","title":"Lane Change"},{"location":"lanelet2_core/LinestringTagging/#more-optional-tags","text":"width with of the line (in m). The linestring then represents the centerline of the object. height height of line (in m). The linestring then represents the lower outline/lowest edge of the object. temporary to indicate lines from construction sites (yes/no). color of the lane marking. White is the default.","title":"More, Optional Tags"},{"location":"lanelet2_core/LinestringTagging/#individual-dashes","text":"Since dashed lines are represented by a full connecting line and not as individual dashes, the information about the position of the dashes is lost. To keep the information, individual points that mark the start and end points of the linestring can be tagged. The type tag is used for that. type=begin marks the begin of the dash (in the orientation of the linestring), type=end marks the end. Other values can be used for other types: * pole (to mark the position of individual poles on guardrails or fences) * dot (to mark dots that form line markings)","title":"Individual Dashes"},{"location":"lanelet2_core/LinestringTagging/#symbols","text":"There can be many different symbols so the selection here is of course incomplete. Symbols can be relevant for some traffic rules Arrows have type=\"arrow\" and a subtype for the direction: subtype: * left * right * straight * straight_left * straight_right * left_right Other types: * stop_line * yield_line * zig-zag * lift_gate * bump * 30/50/70 (for speed limits on the road) The symbol can be represented either by its outline or by its centerline. If it is represented by the centerline, the linestring must only contain two points to avoid confusion with the outline.","title":"Symbols"},{"location":"lanelet2_core/LinestringTagging/#traffic-signs","text":"Traffic signs all have type=traffic_sign . Additionally, they have a \"subtype\"-tag that contains the actual type of the traffic sign. This subtype is encoded as ISO 3166 region code + traffic sign number (e.g. subtype=de206 for a German stop sign or subtype=usR1-1 for a US stop sign ). Traffic signs can be represented either by their outline (as polygon) or by a linestring where the first point is the left edge of the sign and the last point is the right edge of the sign. Optionally the height tag can be used to encode the size of the sign in z (not the height above ground, use the z-coordinate for that). The linestring marks the lower edge of the sign.","title":"Traffic Signs"},{"location":"lanelet2_core/LinestringTagging/#traffic-lights","text":"Traffic signs have type=traffic_light . Similar to traffic signs, they can be represented either by a polygon or a linestring. The subtype tag can be used to add further information on the traffic light: * red_yellow_green * red_yellow * red * etc.","title":"Traffic Lights"},{"location":"lanelet2_core/RegulatoryElementTagging/","text":"Tagging Regulatory Elements Regulatory Elements are divided into categories. The most common ones are TrafficLight , TrafficSign , SpeedLimit and RightOfWay , which are already included in the core library, but there are many more ways to model restrictions on lanelets and areas. More might be added in the future and also users are able to add own regulatory elements by inheriting from the generic RegulatoryElement class and registering the new type using the RegisterRegulatoryElement class. This document describes the generic layout of a Regulatory Element and shows how the common Regulatory Elements are structured. Tags Regulatory Elements always have type=regulatory_element . If this tag is not present, Lanelet2 will add it when writing to an .osm file. Subtype The subtype tag helps Lanelet2 to distinguish between the different regulatory elements. For the basic Regulatory Elements this would be: * traffic_sign * traffic_light * speed_limit * right_of_way * all_way_stop Other, Optional Tags The following tags can be used to add more information to a Regulatory Element (of course you can add you own to enhance your map and implement a new TrafficRule object that implements them). The default values for the tag are highlighted. dynamic (yes/ no ): Indicates that this Regulatory Element might change its meaning based on a condition. Examples would be a road that is closed on weekends. Or a speed limit that is only in action if the road is wet. By default, Lanelet2 cannot handle dynamic Regulatory Elements and will ignore them. Specialized traffic rule classes could be implemented that use background information (such as the current time) to resolve dynamic Regulatory Elements. fallback (yes/ no ): Indicates that this Regulatory Element has a lower priority than another Regulatory Element. Examples are right of way regulations that become valid if the traffic lights of an intersection are out of order. Parameters The main feature of a Regulatory Element is that it can reference other parts of the map that are important for the traffic restriction that they represent. These parts are called parameters of a Regulatory Element. Every parameter is characterized by a role (a string) that explains what he expresses within the Regulatory Element. Multiple parameters can have the same role if they do not contradict. An example of parameters are the traffic lights that referenced by the refers role of a TrafficLight Regulatory Element. These are the traffic lights that a vehicle has to pay attention to when driving along a specific lanelet/area that has this Regulatory Elements. Because parameters with the same role cannot contradict, this means all traffic lights must refer to the same driving direction within that intersection. The most common roles that are used across all regulatory elements are: * refers : The primitive(s) that are the very origin of the restriction. Traffic lights/signs, et cetera. Most Regulatory Elements need a refers role. * cancels : The primitive(s) that mark the end of the restriction (if applicable). * ref_line : The line (usually a LineString) from which a restrictions becomes valid. If not used, that usually means that the whole lanelet/area is affected by the restriction. However, there are exceptions, e.g. for traffic lights the stop line is the end of the lanelet. * cancel_line : The line (usally a LineString) from which a restriction is no longer in place (if applicable) Basic Regulatory Elements Traffic Sign A traffic sign generically expresses a restriction that is expressed by a traffic sign. The refers part refers to traffic signs that form the rule. The cancels parameter then refers to traffic signs that mark the end of the restriction expressed by the sign (e.g. the end of no-overtaking section). The ref_line and cancel_line parameters can then be used to define the exact start and end points of the rule. The LineStrings referenced by that do not necessarily need to have an intersection with the referencing lanelet or Area. If they do, the rule is valid from/to this intersection point. If not, the rule is valid for the whole lanelet/area. Speed Limit Speed limits work very similar to traffic signs. If they are put up by a traffic sign, they simply reference this traffic sign. Similar for the ref_line and the cancels role. The TrafficRules class then takes care of interpreting the speed limit from the subtype of the referenced traffic sign. Alternatively, if the speed limit does not originate from a traffic sign, a sign_type tag can be used to define the speed limit. The value should contain the unit, eg \"50 km/h\". mph or mps or similar units are possible as well. If no unit is given, km/h is assumed. Traffic Light Traffic lights are also similar to traffic signs. Instead of a sign, the light itself is referenced as refers parameter. The cancels and cancels_line role have no meaning for traffic lights. The ref_line can reference the respective stop line. If they are not present, the stop line is implicitly at the end of the lanelet or Area. Right of Way By default, intersecting lanelets are treated as a \"first come first served\" situation, meaning that the vehicle that arrives first at the intersection point has right of way. The RightOfWay Regulatory Element changes this. It has three roles: * yield : References the lanelets that have to yield * right_of_way : the lanelets that have the right of way over the yielding ones * ref_line : The lines where vehicles that are crossing a yield lanelet have to stop at. If not set, this is the end of the yield lanelet. Only one lanelet of a chain of lanelets that belong to the same lane have to be referenced. Generally this is the last lanelet that can be undoubtedly assigned to one specific intersection arm (i.e. the last lanelet before the intersection begins). All lanelets that are mentioned by the right of way Regulatory Element also have to reference the regulatory element. All Way Stop While in a Right of Way regelem, the right of way only depends on the lanelet, the right of way in an All-Way Stop regelem depends on the order of arrival and the route through the intersection. Therefore, all lanelets are potentially yield lanelets. All approaching vehicles have to stop before entering the intersection. The intersection entry is either defined by one stop line for each lanelet or is otherwise determined by the end of each lanelet. To avoid confusion when matching lanelets and stop lines, an All Way Stop regelem is only valid if either no lanelet has a stop line or all lanelets have exactly one. The following roles are used in an all way stop: * yield : References the lanelets that might have to yield * ref_line : The lines where yield lanelets have to stop. This either empty or has the same order and size as the number of lanelets in yield . * refers : The traffic sign(s) that constitute this rule All lanelets referenced in this regelem also have to reference this regelem. OSM XML Examples Below are some examples of regulatory element relations as they might look in lanelet2's OSM XML format. Traffic Light <relation id='1'> <tag k='type' v='regulatory_element' /> <tag k='subtype' v='traffic_light' /> <!-- stop line --> <member type='way' ref='2' role='ref_line' /> <!-- traffic light --> <member type='way' ref='3' role='refers' /> </relation> Speed Limit <relation id='1'> <tag k='subtype' v='speed_limit' /> <tag k='type' v='regulatory_element' /> <!-- Traffic sign(s) that constitute this rule --> <member type='way' ref='2' role='refers' /> </relation> All Way Stop Below is an example of a 4-way stop intersection. <relation id='1'> <tag k='type' v='regulatory_element' /> <tag k='subtype' v='all_way_stop' /> <!-- Lanelets participating in the 4-way stop --> <member type='relation' ref='2' role='yield' /> <member type='relation' ref='3' role='yield' /> <member type='relation' ref='4' role='yield' /> <member type='relation' ref='5' role='yield' /> <!-- Traffic signs that constitute this rule --> <member type='way' ref='6' role='refers' /> <member type='way' ref='7' role='refers' /> <member type='way' ref='8' role='refers' /> <member type='way' ref='9' role='refers' /> <!-- stop lines for the lanelets (same order as lanelets) --> <member type='way' ref='10' role='ref_line' /> <member type='way' ref='11' role='ref_line' /> <member type='way' ref='12' role='ref_line' /> <member type='way' ref='13' role='ref_line' /> </relation>","title":"RegulatoryElementTagging"},{"location":"lanelet2_core/RegulatoryElementTagging/#tagging-regulatory-elements","text":"Regulatory Elements are divided into categories. The most common ones are TrafficLight , TrafficSign , SpeedLimit and RightOfWay , which are already included in the core library, but there are many more ways to model restrictions on lanelets and areas. More might be added in the future and also users are able to add own regulatory elements by inheriting from the generic RegulatoryElement class and registering the new type using the RegisterRegulatoryElement class. This document describes the generic layout of a Regulatory Element and shows how the common Regulatory Elements are structured.","title":"Tagging Regulatory Elements"},{"location":"lanelet2_core/RegulatoryElementTagging/#tags","text":"Regulatory Elements always have type=regulatory_element . If this tag is not present, Lanelet2 will add it when writing to an .osm file.","title":"Tags"},{"location":"lanelet2_core/RegulatoryElementTagging/#subtype","text":"The subtype tag helps Lanelet2 to distinguish between the different regulatory elements. For the basic Regulatory Elements this would be: * traffic_sign * traffic_light * speed_limit * right_of_way * all_way_stop","title":"Subtype"},{"location":"lanelet2_core/RegulatoryElementTagging/#other-optional-tags","text":"The following tags can be used to add more information to a Regulatory Element (of course you can add you own to enhance your map and implement a new TrafficRule object that implements them). The default values for the tag are highlighted. dynamic (yes/ no ): Indicates that this Regulatory Element might change its meaning based on a condition. Examples would be a road that is closed on weekends. Or a speed limit that is only in action if the road is wet. By default, Lanelet2 cannot handle dynamic Regulatory Elements and will ignore them. Specialized traffic rule classes could be implemented that use background information (such as the current time) to resolve dynamic Regulatory Elements. fallback (yes/ no ): Indicates that this Regulatory Element has a lower priority than another Regulatory Element. Examples are right of way regulations that become valid if the traffic lights of an intersection are out of order.","title":"Other, Optional Tags"},{"location":"lanelet2_core/RegulatoryElementTagging/#parameters","text":"The main feature of a Regulatory Element is that it can reference other parts of the map that are important for the traffic restriction that they represent. These parts are called parameters of a Regulatory Element. Every parameter is characterized by a role (a string) that explains what he expresses within the Regulatory Element. Multiple parameters can have the same role if they do not contradict. An example of parameters are the traffic lights that referenced by the refers role of a TrafficLight Regulatory Element. These are the traffic lights that a vehicle has to pay attention to when driving along a specific lanelet/area that has this Regulatory Elements. Because parameters with the same role cannot contradict, this means all traffic lights must refer to the same driving direction within that intersection. The most common roles that are used across all regulatory elements are: * refers : The primitive(s) that are the very origin of the restriction. Traffic lights/signs, et cetera. Most Regulatory Elements need a refers role. * cancels : The primitive(s) that mark the end of the restriction (if applicable). * ref_line : The line (usually a LineString) from which a restrictions becomes valid. If not used, that usually means that the whole lanelet/area is affected by the restriction. However, there are exceptions, e.g. for traffic lights the stop line is the end of the lanelet. * cancel_line : The line (usally a LineString) from which a restriction is no longer in place (if applicable)","title":"Parameters"},{"location":"lanelet2_core/RegulatoryElementTagging/#basic-regulatory-elements","text":"","title":"Basic Regulatory Elements"},{"location":"lanelet2_core/RegulatoryElementTagging/#traffic-sign","text":"A traffic sign generically expresses a restriction that is expressed by a traffic sign. The refers part refers to traffic signs that form the rule. The cancels parameter then refers to traffic signs that mark the end of the restriction expressed by the sign (e.g. the end of no-overtaking section). The ref_line and cancel_line parameters can then be used to define the exact start and end points of the rule. The LineStrings referenced by that do not necessarily need to have an intersection with the referencing lanelet or Area. If they do, the rule is valid from/to this intersection point. If not, the rule is valid for the whole lanelet/area.","title":"Traffic Sign"},{"location":"lanelet2_core/RegulatoryElementTagging/#speed-limit","text":"Speed limits work very similar to traffic signs. If they are put up by a traffic sign, they simply reference this traffic sign. Similar for the ref_line and the cancels role. The TrafficRules class then takes care of interpreting the speed limit from the subtype of the referenced traffic sign. Alternatively, if the speed limit does not originate from a traffic sign, a sign_type tag can be used to define the speed limit. The value should contain the unit, eg \"50 km/h\". mph or mps or similar units are possible as well. If no unit is given, km/h is assumed.","title":"Speed Limit"},{"location":"lanelet2_core/RegulatoryElementTagging/#traffic-light","text":"Traffic lights are also similar to traffic signs. Instead of a sign, the light itself is referenced as refers parameter. The cancels and cancels_line role have no meaning for traffic lights. The ref_line can reference the respective stop line. If they are not present, the stop line is implicitly at the end of the lanelet or Area.","title":"Traffic Light"},{"location":"lanelet2_core/RegulatoryElementTagging/#right-of-way","text":"By default, intersecting lanelets are treated as a \"first come first served\" situation, meaning that the vehicle that arrives first at the intersection point has right of way. The RightOfWay Regulatory Element changes this. It has three roles: * yield : References the lanelets that have to yield * right_of_way : the lanelets that have the right of way over the yielding ones * ref_line : The lines where vehicles that are crossing a yield lanelet have to stop at. If not set, this is the end of the yield lanelet. Only one lanelet of a chain of lanelets that belong to the same lane have to be referenced. Generally this is the last lanelet that can be undoubtedly assigned to one specific intersection arm (i.e. the last lanelet before the intersection begins). All lanelets that are mentioned by the right of way Regulatory Element also have to reference the regulatory element.","title":"Right of Way"},{"location":"lanelet2_core/RegulatoryElementTagging/#all-way-stop","text":"While in a Right of Way regelem, the right of way only depends on the lanelet, the right of way in an All-Way Stop regelem depends on the order of arrival and the route through the intersection. Therefore, all lanelets are potentially yield lanelets. All approaching vehicles have to stop before entering the intersection. The intersection entry is either defined by one stop line for each lanelet or is otherwise determined by the end of each lanelet. To avoid confusion when matching lanelets and stop lines, an All Way Stop regelem is only valid if either no lanelet has a stop line or all lanelets have exactly one. The following roles are used in an all way stop: * yield : References the lanelets that might have to yield * ref_line : The lines where yield lanelets have to stop. This either empty or has the same order and size as the number of lanelets in yield . * refers : The traffic sign(s) that constitute this rule All lanelets referenced in this regelem also have to reference this regelem.","title":"All Way Stop"},{"location":"lanelet2_core/RegulatoryElementTagging/#osm-xml-examples","text":"Below are some examples of regulatory element relations as they might look in lanelet2's OSM XML format.","title":"OSM XML Examples"},{"location":"lanelet2_core/RegulatoryElementTagging/#traffic-light_1","text":"<relation id='1'> <tag k='type' v='regulatory_element' /> <tag k='subtype' v='traffic_light' /> <!-- stop line --> <member type='way' ref='2' role='ref_line' /> <!-- traffic light --> <member type='way' ref='3' role='refers' /> </relation>","title":"Traffic Light"},{"location":"lanelet2_core/RegulatoryElementTagging/#speed-limit_1","text":"<relation id='1'> <tag k='subtype' v='speed_limit' /> <tag k='type' v='regulatory_element' /> <!-- Traffic sign(s) that constitute this rule --> <member type='way' ref='2' role='refers' /> </relation>","title":"Speed Limit"},{"location":"lanelet2_core/RegulatoryElementTagging/#all-way-stop_1","text":"Below is an example of a 4-way stop intersection. <relation id='1'> <tag k='type' v='regulatory_element' /> <tag k='subtype' v='all_way_stop' /> <!-- Lanelets participating in the 4-way stop --> <member type='relation' ref='2' role='yield' /> <member type='relation' ref='3' role='yield' /> <member type='relation' ref='4' role='yield' /> <member type='relation' ref='5' role='yield' /> <!-- Traffic signs that constitute this rule --> <member type='way' ref='6' role='refers' /> <member type='way' ref='7' role='refers' /> <member type='way' ref='8' role='refers' /> <member type='way' ref='9' role='refers' /> <!-- stop lines for the lanelets (same order as lanelets) --> <member type='way' ref='10' role='ref_line' /> <member type='way' ref='11' role='ref_line' /> <member type='way' ref='12' role='ref_line' /> <member type='way' ref='13' role='ref_line' /> </relation>","title":"All Way Stop"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/","text":"Maps, Projections and Coordinate Reference Systems (CRSs) Introduction So, we just store .osm files in LatLon (like GPS) and Lanelet2 converts them to UTM (by default UTM32N), right? Why is there a file for explaining that? Not so fast, my young boy! Let's say we stand on this point and want to know where we are. Let's get our GPS device out, measure the point and we know it, right? Just for the moment. You're still too fast. But, I already incorporated ionospheric distortions, multi-path effects and did a long-time measurement! Well, you still stand in Europe, but your data might very well live in the center of the earth. What do you mean? Look, your GPS device gives you LatLon in the GPS's WGS84 frame, which is fixed to the earth, but the tectonic plate you're standing on is drifting relative to it with about 2.5 cm per year or more than 0.5 m(!) since 1989. Ok, so what do you propose? Lanelet2's conventions Map Files (.osm) .osm maps are stored in EPSG:4258, i.e. we use LatLon as usual, but we define them to be coupled to the European Reference Frame ETRF89. The frame was congruent with ITRF (and somehow WGS84), but is drifting away now. As we do not want to shift our maps every few years, we fix them in ETRF which is good enough (roughly <1 cm local deviation). So, what does that mean for me? For editing in JOSM, we can either pick WGS84 as projection or use EPSG:4258 by EPSG code. This is due to the facts that 1.) JOSM doesn't incorporate the tectonic shift between WGS84/ITRF (WGS84 is not supposed to be much more accurate than 1 m, but it is aligned with ITRF at an accuracy of <0.1 m) and ETRF89 and 2.) the difference between the WGS84 and the GRS80 ellipsoids (GRS80 is the basis for EPSG:4258/ETRF89) is <0.1 mm (even for us that is precise enough). What do I need to think of when importing public OpenStreetMap data? OSM data is by default defined in WGS84, thus you need to incorporate a time-dependent tectonic plate shift. This is supposed to be an option for you in Lanelet2, however you might still need to wiggle around the data a bit as most OpenStreetMap mapper do not care about that 0.5 m difference between ETRF89 and WGS84. Internal Data Lanelet2 loads and reprojects .osm maps to a UTM, but still leaves them in ETRF89, i.e. we use projection EPSG:25832. GPS Data GPS data is in WGS84 and normally temporarily distorted by ionospheric distortions. So, either you compensate both the ionospheric distortions and the continental drift using e.g. SAPOS or you still need to correct the time-dependent drift after compensating for the ionospheric distortions. Martin Lauer already implemented the time-dependent shift, but this you be either an (open) dependency of LLT2 or become part of it (Martin already agreed with it). WIP: A short primer on the most common projections Lanelet1 Projection? What's about the projection used in liblanelet (v1)? It is Mercator but with a customly selected reference point. Would have the advantage of backward compatibility. WGS84 (GPS coordinates, lat/lon, ...) OSM data is stored in WGS84 (aka EPSG:4326) as are GPS positions by definition. It assumes the Earth is an ellipsoid (the corrected WGS84/EGM96; it's quite ok) and references the height w.r.t. this ellipsoid as altitude . However, as we assume that the map is ground-located, we'll refer to this as elevation (as it's done in the OSM standard ). UTM (east/north) By default, UTM is the projection which you probably want to use for everything. Why? It's metric, distances are usually (i.e. within some distance (~180 km) to the reference meridian) okay, i.e. they are at most 0.04 % too short (at the reference meridian) which is 40 cm on 1 km, and the conversion from e.g. WGS84 to UTM is precise up to several nm (yes, nanometers!) if you use Karney's GeographicLib with TransverseMercatorExact as projection. Due to that reason, we use UTM as projection for internal data representation in Lanelet2 with a default of UTM32N. However, we do not use EPSG:32632 (which is what UTM32N commonly refers to) as one could expect, but EPSG:25832. This means that we stay local to the ETRF89 and thus fixed to the European tectonic plate, but everything else is the same as with the 'normal' UTM32N. The WGS84/GRS80 (EPSG:32632/EPSG:25832) ellipsoid difference is negligible (<0.1 mm). Web Mercator Google Maps, Bing Maps and OSM Tiles are in Web Mercator. This is similar to WGS84, but uses a spherical assumptions. This is not supposed to be used in Lanelet2. Links Things to know A guide to coordinate systems (in great britain) Transverse Mercator with an accuracy of a few nanometers arXiv Mirror Algorithms for geodesics arXiv Mirror Geodesics on an ellipsoid of revolution Karney's GeographicLib Vincenty's Formulae (Note: Karney's work and his solution to the inverse Geodesic problem (given two points, what's the distance?) obliterate Vincenty's method. Only the performance should be compared as Vincenty's method is already sufficiently accurate for our use cases.) Height-related stuff Sind die Bezugssysteme WGS84 und ETRS89 wirklich gleich? A tutorial on Datums Elevation in OSM Altitude in OSM Mean Sea Level, GPS, and the Geoid","title":"Map_Projections_Coordinate_Systems"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#maps-projections-and-coordinate-reference-systems-crss","text":"","title":"Maps, Projections and Coordinate Reference Systems (CRSs)"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#introduction","text":"So, we just store .osm files in LatLon (like GPS) and Lanelet2 converts them to UTM (by default UTM32N), right? Why is there a file for explaining that? Not so fast, my young boy! Let's say we stand on this point and want to know where we are. Let's get our GPS device out, measure the point and we know it, right? Just for the moment. You're still too fast. But, I already incorporated ionospheric distortions, multi-path effects and did a long-time measurement! Well, you still stand in Europe, but your data might very well live in the center of the earth. What do you mean? Look, your GPS device gives you LatLon in the GPS's WGS84 frame, which is fixed to the earth, but the tectonic plate you're standing on is drifting relative to it with about 2.5 cm per year or more than 0.5 m(!) since 1989. Ok, so what do you propose?","title":"Introduction"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#lanelet2s-conventions","text":"","title":"Lanelet2's conventions"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#map-files-osm","text":".osm maps are stored in EPSG:4258, i.e. we use LatLon as usual, but we define them to be coupled to the European Reference Frame ETRF89. The frame was congruent with ITRF (and somehow WGS84), but is drifting away now. As we do not want to shift our maps every few years, we fix them in ETRF which is good enough (roughly <1 cm local deviation). So, what does that mean for me? For editing in JOSM, we can either pick WGS84 as projection or use EPSG:4258 by EPSG code. This is due to the facts that 1.) JOSM doesn't incorporate the tectonic shift between WGS84/ITRF (WGS84 is not supposed to be much more accurate than 1 m, but it is aligned with ITRF at an accuracy of <0.1 m) and ETRF89 and 2.) the difference between the WGS84 and the GRS80 ellipsoids (GRS80 is the basis for EPSG:4258/ETRF89) is <0.1 mm (even for us that is precise enough). What do I need to think of when importing public OpenStreetMap data? OSM data is by default defined in WGS84, thus you need to incorporate a time-dependent tectonic plate shift. This is supposed to be an option for you in Lanelet2, however you might still need to wiggle around the data a bit as most OpenStreetMap mapper do not care about that 0.5 m difference between ETRF89 and WGS84.","title":"Map Files (.osm)"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#internal-data","text":"Lanelet2 loads and reprojects .osm maps to a UTM, but still leaves them in ETRF89, i.e. we use projection EPSG:25832.","title":"Internal Data"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#gps-data","text":"GPS data is in WGS84 and normally temporarily distorted by ionospheric distortions. So, either you compensate both the ionospheric distortions and the continental drift using e.g. SAPOS or you still need to correct the time-dependent drift after compensating for the ionospheric distortions. Martin Lauer already implemented the time-dependent shift, but this you be either an (open) dependency of LLT2 or become part of it (Martin already agreed with it).","title":"GPS Data"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#wip-a-short-primer-on-the-most-common-projections","text":"","title":"WIP: A short primer on the most common projections"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#lanelet1-projection","text":"What's about the projection used in liblanelet (v1)? It is Mercator but with a customly selected reference point. Would have the advantage of backward compatibility.","title":"Lanelet1 Projection?"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#wgs84-gps-coordinates-latlon","text":"OSM data is stored in WGS84 (aka EPSG:4326) as are GPS positions by definition. It assumes the Earth is an ellipsoid (the corrected WGS84/EGM96; it's quite ok) and references the height w.r.t. this ellipsoid as altitude . However, as we assume that the map is ground-located, we'll refer to this as elevation (as it's done in the OSM standard ).","title":"WGS84 (GPS coordinates, lat/lon, ...)"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#utm-eastnorth","text":"By default, UTM is the projection which you probably want to use for everything. Why? It's metric, distances are usually (i.e. within some distance (~180 km) to the reference meridian) okay, i.e. they are at most 0.04 % too short (at the reference meridian) which is 40 cm on 1 km, and the conversion from e.g. WGS84 to UTM is precise up to several nm (yes, nanometers!) if you use Karney's GeographicLib with TransverseMercatorExact as projection. Due to that reason, we use UTM as projection for internal data representation in Lanelet2 with a default of UTM32N. However, we do not use EPSG:32632 (which is what UTM32N commonly refers to) as one could expect, but EPSG:25832. This means that we stay local to the ETRF89 and thus fixed to the European tectonic plate, but everything else is the same as with the 'normal' UTM32N. The WGS84/GRS80 (EPSG:32632/EPSG:25832) ellipsoid difference is negligible (<0.1 mm).","title":"UTM (east/north)"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#web-mercator","text":"Google Maps, Bing Maps and OSM Tiles are in Web Mercator. This is similar to WGS84, but uses a spherical assumptions. This is not supposed to be used in Lanelet2.","title":"Web Mercator"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#links","text":"","title":"Links"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#things-to-know","text":"A guide to coordinate systems (in great britain) Transverse Mercator with an accuracy of a few nanometers arXiv Mirror Algorithms for geodesics arXiv Mirror Geodesics on an ellipsoid of revolution Karney's GeographicLib Vincenty's Formulae (Note: Karney's work and his solution to the inverse Geodesic problem (given two points, what's the distance?) obliterate Vincenty's method. Only the performance should be compared as Vincenty's method is already sufficiently accurate for our use cases.)","title":"Things to know"},{"location":"lanelet2_projection/Map_Projections_Coordinate_Systems/#height-related-stuff","text":"Sind die Bezugssysteme WGS84 und ETRS89 wirklich gleich? A tutorial on Datums Elevation in OSM Altitude in OSM Mean Sea Level, GPS, and the Geoid","title":"Height-related stuff"}]}
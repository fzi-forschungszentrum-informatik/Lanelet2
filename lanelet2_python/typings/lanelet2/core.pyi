from enum import Enum
from typing import Dict, Iterator, List, Optional, Sequence, Union, overload


class AttributeMap(Dict[str, str]):
    """
    Stores attributes as key-value pairs.
    """

    def __init__(
        self, attributes: Optional[Dict[str, str]] = None) -> None: ...

    def __repr__(self) -> str: ...


class RuleParameterMap(Dict[str, List[Union['Point3d', 'LineString3d', 'Polygon3d', 'Lanelet', 'Area']]]):
    """
    Map of rule parameters.
    """

    def __repr__(self) -> str: ...


class BasicPoint2d:
    """A simple 2D point."""
    x: float
    y: float

    def __init__(self, x: float = 0.0, y: float = 0.0) -> None: ...
    def __repr__(self) -> str: ...
    def __add__(self, other: 'BasicPoint2d') -> 'BasicPoint2d': ...
    def __sub__(self, other: 'BasicPoint2d') -> 'BasicPoint2d': ...
    def __mul__(self, other: float) -> 'BasicPoint2d': ...
    def __rmul__(self, other: float) -> 'BasicPoint2d': ...
    def __div__(self, other: float) -> 'BasicPoint2d': ...


class BasicPoint3d:
    """A simple 3D point."""
    x: float
    y: float
    z: float

    def __init__(self, x: float = 0.0, y: float = 0.0,
                 z: float = 0.0) -> None: ...

    def __repr__(self) -> str: ...
    def __add__(self, other: 'BasicPoint3d') -> 'BasicPoint3d': ...
    def __sub__(self, other: 'BasicPoint3d') -> 'BasicPoint3d': ...
    def __mul__(self, other: float) -> 'BasicPoint3d': ...
    def __rmul__(self, other: float) -> 'BasicPoint3d': ...
    def __div__(self, other: float) -> 'BasicPoint3d': ...


class BoundingBox2d:
    """
    Represents a 2D bounding box.
    """
    min: BasicPoint2d
    max: BasicPoint2d

    def __init__(self, min: BasicPoint2d, max: BasicPoint2d) -> None: ...
    def __repr__(self) -> str: ...


class BoundingBox3d:
    """
    Represents a 3D bounding box.
    """
    min: BasicPoint3d
    max: BasicPoint3d

    def __init__(self, min: BasicPoint3d, max: BasicPoint3d) -> None: ...
    def __repr__(self) -> str: ...


class ConstPoint2d:
    """
    Immutable 2D point primitive.
    """
    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    def basicPoint(self) -> 'BasicPoint2d': ...
    def __repr__(self) -> str: ...


class Point2d(ConstPoint2d):
    """
    Lanelet's 2D point primitive.
    """
    @overload
    def __init__(self, id: int, x: float, y: float, z: float = 0.0,
                 attributes: 'AttributeMap' = AttributeMap()) -> None: ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, point: 'Point3d') -> None: ...

    @overload
    def __init__(self, point: BasicPoint3d,
                 attributes: 'AttributeMap') -> None: ...

    @ConstPoint2d.id.setter
    def id(self, value: int) -> None: ...
    @ConstPoint2d.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    @ConstPoint2d.x.setter
    def x(self, value: float) -> None: ...
    @ConstPoint2d.y.setter
    def y(self, value: float) -> None: ...
    def __repr__(self) -> str: ...


class ConstPoint3d:
    """
    Immutable 3D point primitive. 

    It can not be instanciated from python but is returned from a few lanelet2 algorithms.
    """
    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...
    def basicPoint(self) -> 'BasicPoint3d': ...
    def __repr__(self) -> str: ...


class Point3d(ConstPoint3d):
    """
    Represents a 3D point.
    """
    @overload
    def __init__(self, id: int, x: float = 0.0, y: float = 0.0, z: float = 0.0,
                 attributes: Optional['AttributeMap'] = None) -> None: ...

    @overload
    def __init__(self, point: 'Point3d') -> None: ...

    @overload
    def __init__(self, point: BasicPoint3d,
                 attributes: 'AttributeMap') -> None: ...

    @ConstPoint3d.id.setter
    def id(self, value: int) -> None: ...
    @ConstPoint3d.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    @ConstPoint3d.x.setter
    def x(self, value: float) -> None: ...
    @ConstPoint3d.y.setter
    def y(self, value: float) -> None: ...
    @ConstPoint3d.z.setter
    def z(self, value: float) -> None: ...
    def __repr__(self) -> str: ...


class ConstLineString2d:
    """
    Immutable 2D line string.
    """

    def __init__(self, linestring: 'ConstLineString3d') -> None: ...
    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def invert(self) -> 'ConstLineString2d': ...
    def __iter__(self) -> 'Iterator[ConstPoint2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint2d': ...
    def __repr__(self) -> str: ...
    def inverted(self) -> bool: ...


class LineString2d(ConstLineString2d):
    """
    Represents a mutable 2D line string.
    """
    @overload
    def __init__(self, id: int, points: List[Point2d],
                 attributes: AttributeMap = AttributeMap()) -> None: ...

    @overload
    def __init__(self, linestring: 'LineString3d') -> None: ...
    @ConstLineString2d.id.setter
    def id(self, value: int) -> None: ...
    @ConstLineString2d.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    def invert(self) -> 'LineString2d': ...
    def __iter__(self) -> 'Iterator[Point2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'Point2d': ...
    def __setitem__(self, index: int, value: 'Point2d') -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def append(self, point: 'Point2d') -> None: ...
    def __repr__(self) -> str: ...


class ConstLineString3d:
    """
    Immutable 3D line string.
    """
    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def __init__(self, linestring: 'ConstLineString3d') -> None: ...
    def invert(self) -> 'ConstLineString3d': ...
    def __iter__(self) -> 'Iterator[ConstPoint3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint3d': ...
    def __repr__(self) -> str: ...
    def inverted(self) -> bool: ...


class LineString3d(ConstLineString3d):
    """
    Represents a mutable 3D line string.
    """
    @overload
    def __init__(
        self, id: int, points: List['Point3d'], attributes: 'AttributeMap' = AttributeMap()) -> None: ...

    @overload
    def __init__(self, linestring: 'LineString3d') -> None: ...

    @ConstLineString3d.id.setter
    def id(self, value: int) -> None: ...
    @ConstLineString3d.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    def invert(self) -> 'LineString3d': ...
    def __iter__(self) -> 'Iterator[Point3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'Point3d': ...
    def __setitem__(self, index: int, value: 'Point3d') -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def append(self, point: 'Point3d') -> None: ...
    def __repr__(self) -> str: ...
    def inverted(self) -> bool: ...


class ConstHybridLineString2d:
    """
    A hybrid 2D Linestring.

    Behaves like a normal BasicLineString (i.e. returns BasicPoints) 
    but still has an ID and attributes.
    """

    def __init__(
        self, id: int, points: List['ConstPoint2d'], attributes: 'AttributeMap') -> None: ...

    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def invert(self) -> 'ConstHybridLineString2d': ...
    def __iter__(self) -> 'Iterator[BasicPoint2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'BasicPoint2d': ...
    def __repr__(self) -> str: ...
    def inverted(self) -> bool: ...


class ConstHybridLineString3d:
    """
    A hybrid 3D Linestring.

    Behaves like a normal BasicLineString (i.e. returns BasicPoints)
    """

    def __init__(
        self, id: int, points: List['ConstPoint3d'], attributes: 'AttributeMap') -> None: ...

    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def invert(self) -> 'ConstHybridLineString3d': ...
    def __iter__(self) -> 'Iterator[BasicPoint2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'BasicPoint2d': ...
    def __repr__(self) -> str: ...
    def inverted(self) -> bool: ...


class CompoundLineString2d:
    """
    Represents a 2D linestring composed of multiple linestrings.
    """

    def __init__(self, linestrings: List['ConstLineString2d']) -> None: ...
    def __iter__(self) -> 'Iterator[ConstPoint2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint2d': ...
    def lineStrings(self) -> List['ConstLineString2d']: ...
    def ids(self) -> List[int]: ...


class CompoundLineString3d:
    """
    Represents a 3D linestring composed of multiple linestrings.
    """

    def __init__(self, linestrings: List['ConstLineString3d']) -> None: ...
    def __iter__(self) -> 'Iterator[ConstPoint3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint3d': ...
    def lineStrings(self) -> List['ConstLineString3d']: ...
    def ids(self) -> List[int]: ...


class ConstPolygon2d:
    """
    Immutable 2D polygon.
    """
    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def __init__(
        self, id: int, points: List['Point2d'], attributes: 'AttributeMap') -> None: ...

    def __iter__(self) -> 'Iterator[ConstPoint2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint2d': ...
    def __repr__(self) -> str: ...


class Polygon2d(ConstPolygon2d):
    """
    Represents a mutable 2D polygon.

    Points in clockwise order and open (i.e. start point != end point).
    """

    def __init__(
        self, id: int, points: List['Point2d'], attributes: 'AttributeMap') -> None: ...

    @ConstPolygon2d.id.setter
    def id(self, value: int) -> None: ...
    @ConstPolygon2d.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    def __iter__(self) -> 'Iterator[Point2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'Point2d': ...
    def __setitem__(self, index: int, value: 'Point2d') -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def __repr__(self) -> str: ...


class ConstPolygon3d:
    """
    Immutable 3D polygon.
    """
    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def __init__(
        self, id: int, points: List['Point3d'], attributes: 'AttributeMap') -> None: ...

    def __iter__(self) -> 'Iterator[ConstPoint3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint3d': ...
    def __repr__(self) -> str: ...


class Polygon3d(ConstPolygon3d):
    """
    Represents a mutable 3D polygon.

    Points in clockwise order and open (i.e. start point != end point).
    """

    def __init__(
        self, id: int, points: List['Point3d'], attributes: 'AttributeMap') -> None: ...

    @ConstPolygon3d.id.setter
    def id(self, value: int) -> None: ...
    @ConstPolygon3d.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    def __iter__(self) -> 'Iterator[Point3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'Point3d': ...
    def __setitem__(self, index: int, value: 'Point3d') -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def __repr__(self) -> str: ...


class CompoundPolygon2d:
    """
    Represents a 2D polygon composed of multiple linestings.
    """

    def __init__(self, linestrings: List['ConstLineString2d']) -> None: ...
    def __iter__(self) -> 'Iterator[ConstPoint2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint2d': ...
    def lineStrings(self) -> List['ConstLineString2d']: ...
    def ids(self) -> List[int]: ...


class CompoundPolygon3d:
    """
    Represents a 3D polygon composed of multiple linestings.
    """

    def __init__(self, linestrings: List['ConstLineString3d']) -> None: ...
    def __iter__(self) -> 'Iterator[ConstPoint3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstPoint3d': ...
    def lineStrings(self) -> List['ConstLineString3d']: ...
    def ids(self) -> List[int]: ...


class ConstHybridPolygon2d:
    """
    A hybrid 2D Polygon.

    Behaves like a normal BasicPolygon (i.e. returns BasicPoints)
    but still has an ID and attributes.
    """

    def __init__(
        self, id: int, points: List['ConstPoint2d'], attributes: 'AttributeMap') -> None: ...

    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def __iter__(self) -> 'Iterator[BasicPoint2d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'BasicPoint2d': ...
    def __repr__(self) -> str: ...


class ConstHybridPolygon3d:
    """
    A hybrid 3D Polygon.

    Behaves like a normal BasicPolygon (i.e. returns BasicPoints)
    but still has an ID and attributes.
    """

    def __init__(
        self, id: int, points: List['ConstPoint3d'], attributes: 'AttributeMap') -> None: ...

    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    def __iter__(self) -> 'Iterator[BasicPoint3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'BasicPoint3d': ...
    def __repr__(self) -> str: ...


class ConstLanelet:
    """
    An immutable lanelet primitive.

    Consist of a left and right boundary, attributes and a set of
    traffic rules that apply here. It is not very useful within python,
    but returned by some lanelet2 algorihms.
    """

    def __init__(self, id: int, leftBound: 'LineString3d', rightBound: 'LineString3d',
                 attributes: 'AttributeMap', regelems: List['RegulatoryElement']) -> None: ...

    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    @property
    def centerline(self) -> 'ConstLineString3d': ...
    @property
    def leftBound(self) -> 'ConstLineString3d': ...
    @property
    def rightBound(self) -> 'ConstLineString3d': ...
    @property
    def regulatoryElements(self) -> List['RegulatoryElement']: ...
    def trafficLights(self) -> List['TrafficLight']: ...
    def trafficSigns(self) -> List['TrafficSign']: ...
    def speedLimits(self) -> List['SpeedLimit']: ...
    def rightOfWay(self) -> List['RightOfWay']: ...
    def allWayStop(self) -> List['AllWayStop']: ...
    def invert(self) -> 'ConstLanelet': ...
    def inverted(self) -> bool: ...
    def polygon2d(self) -> 'CompoundPolygon2d': ...
    def polygon3d(self) -> 'CompoundPolygon3d': ...
    def resetCache(self) -> None: ...
    def __repr__(self) -> str: ...


class Lanelet(ConstLanelet):
    """
    Represents a lanelet with boundaries, attributes, and regulatory elements.
    """

    def __init__(self, id: int, leftBound: 'LineString3d', rightBound: 'LineString3d',
                 attributes: 'AttributeMap' = AttributeMap(), regelems: List['RegulatoryElement'] = []) -> None: ...

    leftBound: LineString3d  # type: ignore
    rightBound: LineString3d  # type: ignore
    centerline: LineString3d  # type: ignore

    @ConstLanelet.id.setter
    def id(self, value: int) -> None: ...
    @ConstLanelet.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    def addRegulatoryElement(self, regelem: 'RegulatoryElement') -> None: ...
    def removeRegulatoryElement(
        self, regelem: 'RegulatoryElement') -> None: ...

    def invert(self) -> 'Lanelet': ...
    def __repr__(self) -> str: ...


class LaneletSequence:
    """
    A combined lane formed from multiple lanelets.
    """

    def __init__(self, lanelets: Sequence['ConstLanelet']) -> None: ...

    @property
    def centerline(self) -> 'CompoundLineString3d': ...
    @property
    def leftBound(self) -> 'CompoundLineString3d': ...
    @property
    def rightBound(self) -> 'CompoundLineString3d': ...
    def invert(self) -> 'LaneletSequence': ...
    def polygon2d(self) -> 'CompoundPolygon2d': ...
    def polygon3d(self) -> 'CompoundPolygon3d': ...
    def lanelets(self) -> List['ConstLanelet']: ...
    def __iter__(self) -> 'Iterator[ConstLanelet]': ...
    def __len__(self) -> int: ...
    def inverted(self) -> bool: ...
    def __repr__(self) -> str: ...
    def __getitem__(self, index: int) -> 'ConstLanelet': ...


class ConstLaneletWithStopLine:
    """
    Represents a lanelet with an optional stop line.
    """
    lanelet: ConstLanelet
    stopLine: Optional[ConstLineString3d]

    def __init__(self, lanelet: 'ConstLanelet',
                 stopLine: Optional['ConstLineString3d'] = None) -> None: ...


class LaneletWithStopLine:
    """
    Represents a lanelet with a stop line.
    """
    lanelet: Lanelet
    stopLine: Optional[LineString3d]

    def __init__(self, lanelet: 'Lanelet',
                 stopLine: Optional['LineString3d'] = None) -> None: ...


class ConstInnerBounds:
    """
    Immutable list-like type to hold inner boundaries of an Area.
    """

    def __init__(self, innerBounds: List['LineString3d']) -> None: ...

    def __iter__(self) -> 'Iterator[ConstLineString3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'ConstLineString3d': ...
    def __repr__(self) -> str: ...


class InnerBounds:
    """
    List-like type to hold inner boundaries of an Area.
    """

    def __init__(self, innerBounds: List['LineString3d']) -> None: ...

    def __setitem__(self, index: int, value: 'LineString3d') -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def append(self, hole: 'LineString3d') -> None: ...
    def __iter__(self) -> 'Iterator[LineString3d]': ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> 'LineString3d': ...
    def __repr__(self) -> str: ...


class ConstArea:
    """
    Represents an immutable area with optional holes.
    """

    def __init__(self, id: int, outerBound: List['LineString3d'], innerBounds: List[List[LineString3d]] = [],
                 attributes: 'AttributeMap' = AttributeMap(), regulatoryElements: List['RegulatoryElement'] = []) -> None: ...

    @property
    def id(self) -> int: ...
    @property
    def attributes(self) -> 'AttributeMap': ...
    @property
    def outerBound(self) -> List['ConstLineString3d']: ...
    @property
    def innerBounds(self) -> 'ConstInnerBounds': ...
    @property
    def regulatoryElements(self) -> List['RegulatoryElement']: ...
    def outerBoundPolygon(self) -> 'CompoundPolygon3d': ...
    def innerBoundsPolygons(self) -> List['CompoundPolygon3d']: ...
    def __repr__(self) -> str: ...


class Area(ConstArea):
    """
    Represents an area with optional holes.
    """

    def __init__(self, id: int, outerBound: List['LineString3d'], innerBounds: List[List[LineString3d]] = [],
                 attributes: 'AttributeMap' = AttributeMap(), regulatoryElements: List['RegulatoryElement'] = []) -> None: ...

    outerBound: List[LineString3d]  # type: ignore
    innerBounds: InnerBounds  # type: ignore
    regulatoryElements: List[RegulatoryElement]  # type: ignore

    @ConstArea.id.setter
    def id(self, value: int) -> None: ...
    @ConstArea.attributes.setter
    def attributes(self, value: 'AttributeMap') -> None: ...
    def addRegulatoryElement(self, regelem: 'RegulatoryElement') -> None: ...
    def removeRegulatoryElement(
        self, regelem: 'RegulatoryElement') -> None: ...

    def __repr__(self) -> str: ...


class GPSPoint:
    """
    A raw GPS point.
    """
    lat: float
    lon: float
    ele: float

    def __init__(self, lat: float = 0.0,
                 lon: float = 0.0, ele: float = 0.0) -> None: ...

    def __repr__(self) -> str: ...


class ConstRuleParameterMap(Dict[str, List[Union['ConstPoint3d', 'ConstLineString3d', 'ConstPolygon3d', 'ConstLanelet', 'ConstArea']]]):
    """
    Immutable map of rule parameters.
    """

    def __repr__(self) -> str: ...


class RegulatoryElement:
    """
    Represents a regulatory element that defines traffic rules.
    """
    id: int
    attributes: AttributeMap
    parameters: RuleParameterMap
    @property
    def roles(self) -> List[str]: ...
    def find(self, id: int) -> Optional[Union['ConstPoint3d',
                                              'ConstLineString3d', 'ConstPolygon3d', 'ConstLanelet', 'ConstArea']]: ...

    def __len__(self) -> int: ...
    def __repr__(self) -> str: ...


class TrafficLight(RegulatoryElement):
    """
    Represents a traffic light regulatory element.
    """
    stopLine: Optional[LineString3d]

    def __init__(self, id: int, attributes: 'AttributeMap',
                 trafficLights: List[Union['LineString3d', 'Polygon3d']],
                 stopLine: Optional['LineString3d'] = None) -> None: ...

    def removeStopLine(self) -> None: ...
    @property
    def trafficLights(self) -> List[Union['LineString3d', 'Polygon3d']]: ...

    def addTrafficLight(
        self, trafficLight: Union['LineString3d', 'Polygon3d']) -> None: ...
    def removeTrafficLight(
        self, trafficLight: Union['LineString3d', 'Polygon3d']) -> bool: ...

    def __repr__(self) -> str: ...


class ManeuverType(Enum):
    Yield = 0
    RightOfWay = 1
    Unknown = 2


class RightOfWay(RegulatoryElement):
    """
    Represents a right of way regulatory element.
    """
    stopLine: Optional[LineString3d]

    def __init__(self, id: int, attributes: 'AttributeMap', rightOfWayLanelets:
                 List['Lanelet'], yieldLanelets: List['Lanelet'], stopLine: Optional['LineString3d'] = None) -> None: ...

    def rightOfWayLanelets(self) -> List['Lanelet']: ...
    def addRightOfWayLanelet(self, rightOfWayLanelet: 'Lanelet') -> None: ...
    def removeRightOfWayLanelet(
        self, rightOfWayLanelet: 'Lanelet') -> bool: ...

    def removeStopLine(self) -> None: ...
    def yieldLanelets(self) -> List['Lanelet']: ...
    def addYieldLanelet(self, yieldLanelet: 'Lanelet') -> None: ...
    def removeYieldLanelet(self, yieldLanelet: 'Lanelet') -> bool: ...
    def getManeuver(self, lanelet: 'ConstLanelet') -> 'ManeuverType': ...
    def __repr__(self) -> str: ...


class AllWayStop(RegulatoryElement):
    """
    Represents an all way stop regulatory element.
    """

    def __init__(self, id: int, attributes: 'AttributeMap',
                 lltsWithStop: List[LaneletWithStopLine], signs: List[Union['LineString3d', 'Polygon3d']] = []) -> None: ...

    def lanelets(self) -> List['Lanelet']: ...
    def stopLines(self) -> List[LineString3d]: ...
    def trafficSigns(self) -> List[Union['LineString3d', 'Polygon3d']]: ...

    def addTrafficSign(
        self, trafficSign: Union['LineString3d', 'Polygon3d']) -> None: ...
    def removeTrafficSign(
        self, trafficSign: Union['LineString3d', 'Polygon3d']) -> bool: ...

    def addLanelet(self, lanelet: 'LaneletWithStopLine') -> None: ...
    def removeLanelet(self, lanelet: 'Lanelet') -> bool: ...
    def __repr__(self) -> str: ...


class TrafficSignWithType:

    """
    Combines a traffic sign with its type.

    Used for the TrafficSign regulatory element.
    """
    trafficSigns: List[Union['LineString3d', 'Polygon3d']]
    type: str

    def __init__(self, trafficSign: 'TrafficSign', type: str = "") -> None: ...


class TrafficSign(RegulatoryElement):
    """
    Represents a traffic sign regulatory element.
    """

    def __init__(self, id: int, attributes: 'AttributeMap', trafficSigns: List['TrafficSignWithType'], cancellingTrafficSigns: List['TrafficSignWithType'] = [
    ], refLines: List['LineString3d'] = [], cancelLines: List['LineString3d'] = []) -> None: ...
    def trafficSigns(self) -> List[Union['LineString3d', 'Polygon3d']]: ...
    def cancellingTrafficSigns(
        self) -> List[Union['LineString3d', 'Polygon3d']]: ...

    def refLines(self) -> List['LineString3d']: ...
    def cancelLines(self) -> List['LineString3d']: ...

    def addTrafficSign(
        self, trafficSign: Union['LineString3d', 'Polygon3d'], type: str) -> None: ...
    def removeTrafficSign(
        self, trafficSign: Union['LineString3d', 'Polygon3d']) -> bool: ...

    def addRefLine(self, refLine: 'LineString3d') -> None: ...
    def removeRefLine(self, refLine: 'LineString3d') -> bool: ...

    def addCancellingTrafficSign(
        self, trafficSign: Union['LineString3d', 'Polygon3d'], type: str) -> None: ...
    def removeCancellingTrafficSign(
        self, trafficSign: Union['LineString3d', 'Polygon3d']) -> bool: ...

    def addCancellingRefLine(self, refLine: 'LineString3d') -> None: ...
    def removeCancellingRefLine(self, refLine: 'LineString3d') -> bool: ...
    def type(self) -> str: ...
    def cancelTypes(self) -> List[str]: ...
    def __repr__(self) -> str: ...


class SpeedLimit(TrafficSign):
    """
    Represents a speed limit regulatory element.
    """

    def __init__(self, id: int, attributes: 'AttributeMap', trafficSigns: List['TrafficSignWithType'], cancellingTrafficSigns: List['TrafficSignWithType'] = [
    ], refLines: List['LineString3d'] = [], cancelLines: List['LineString3d'] = []) -> None: ...

    def __repr__(self) -> str: ...


class AreaLayer:
    """
    Map layer within a lanelet map that contains areas.
    """

    def exists(self, id: int) -> bool: ...
    @overload
    def __contains__(self, id: int) -> bool: ...
    @overload
    def __contains__(self, area: 'Area') -> bool: ...
    def get(self, id: int) -> Optional['Area']: ...
    def __getitem__(self, id: int) -> 'Area': ...
    def __iter__(self) -> 'Iterator[Area]': ...
    def __len__(self) -> int: ...
    def search(self, boundingBox: 'BoundingBox2d') -> List['Area']: ...
    def nearest(self, point: 'BasicPoint2d', n: int) -> List['Area']: ...
    def uniqueId(self) -> int: ...
    @overload
    def findUsages(self, regelem: 'RegulatoryElement') -> List['Area']: ...
    @overload
    def findUsages(self, ls: 'ConstLineString3d') -> List['Area']: ...


class LaneletLayer:
    """
    Map layer within a lanelet map that contains lanelets.
    """

    def exists(self, id: int) -> bool: ...
    @overload
    def __contains__(self, id: int) -> bool: ...
    @overload
    def __contains__(self, lanelet: 'Lanelet') -> bool: ...
    def get(self, id: int) -> Optional['Lanelet']: ...
    def __getitem__(self, id: int) -> 'Lanelet': ...
    def __iter__(self) -> 'Iterator[Lanelet]': ...
    def __len__(self) -> int: ...
    def search(self, boundingBox: 'BoundingBox2d') -> List['Lanelet']: ...
    def nearest(self, point: 'BasicPoint2d', n: int) -> List['Lanelet']: ...
    def uniqueId(self) -> int: ...
    @overload
    def findUsages(self, regelem: 'RegulatoryElement') -> List['Lanelet']: ...
    @overload
    def findUsages(self, ls: 'ConstLineString3d') -> List['Lanelet']: ...


class PolygonLayer:
    """
    Map layer within a lanelet map that contains polygons.
    """

    def exists(self, id: int) -> bool: ...
    @overload
    def __contains__(self, id: int) -> bool: ...
    @overload
    def __contains__(self, polygon: 'Polygon3d') -> bool: ...
    def get(self, id: int) -> Optional['Polygon3d']: ...
    def __getitem__(self, id: int) -> 'Polygon3d': ...
    def __iter__(self) -> 'Iterator[Polygon3d]': ...
    def __len__(self) -> int: ...
    def search(self, boundingBox: 'BoundingBox2d') -> List['Polygon3d']: ...
    def nearest(self, point: 'BasicPoint2d', n: int) -> List['Polygon3d']: ...
    def uniqueId(self) -> int: ...

    @overload
    def findUsages(
        self, regelem: 'RegulatoryElement') -> List['Polygon3d']: ...

    @overload
    def findUsages(self, ls: 'ConstLineString3d') -> List['Polygon3d']: ...


class LineStringLayer:
    """
    Map layer within a lanelet map that contains linestrings.
    """

    def exists(self, id: int) -> bool: ...
    @overload
    def __contains__(self, id: int) -> bool: ...
    @overload
    def __contains__(self, linestring: 'LineString3d') -> bool: ...
    def get(self, id: int) -> Optional['LineString3d']: ...
    def __getitem__(self, id: int) -> 'LineString3d': ...
    def __iter__(self) -> 'Iterator[LineString3d]': ...
    def __len__(self) -> int: ...
    def search(self, boundingBox: 'BoundingBox2d') -> List['LineString3d']: ...
    def nearest(self, point: 'BasicPoint3d',
                n: int) -> List['LineString2d']: ...

    def uniqueId(self) -> int: ...
    def findUsages(self, regelem: 'ConstPoint3d') -> List['LineString3d']: ...


class PointLayer:
    """
    Map layer within a lanelet map that contains points.
    """

    def exists(self, id: int) -> bool: ...
    @overload
    def __contains__(self, id: int) -> bool: ...
    @overload
    def __contains__(self, point: 'Point3d') -> bool: ...
    def get(self, id: int) -> Optional['Point3d']: ...
    def __getitem__(self, id: int) -> 'Point3d': ...
    def __iter__(self) -> 'Iterator[Point3d]': ...
    def __len__(self) -> int: ...
    def search(self, boundingBox: 'BoundingBox2d') -> List['Point3d']: ...
    def nearest(self, point: 'BasicPoint2d', n: int) -> List['Point3d']: ...
    def uniqueId(self) -> int: ...


class RegulatoryElementLayer:
    """
    Map layer within a lanelet map that contains regulatory elements.
    """

    def exists(self, id: int) -> bool: ...
    @overload
    def __contains__(self, id: int) -> bool: ...
    @overload
    def __contains__(self, regelem: 'RegulatoryElement') -> bool: ...
    def get(self, id: int) -> Optional['RegulatoryElement']: ...
    def __getitem__(self, id: int) -> 'RegulatoryElement': ...
    def __iter__(self) -> 'Iterator[RegulatoryElement]': ...
    def __len__(self) -> int: ...

    def search(
        self, boundingBox: 'BoundingBox3d') -> List['RegulatoryElement']: ...
    def nearest(self, point: 'BasicPoint3d',
                n: int) -> List['RegulatoryElement']: ...

    def uniqueId(self) -> int: ...


class LaneletMapLayers:
    """
    A collection of map layers within a lanelet map.
    """
    @property
    def pointLayer(self) -> 'PointLayer': ...
    @property
    def lineStringLayer(self) -> 'LineStringLayer': ...
    @property
    def polygonLayer(self) -> 'PolygonLayer': ...
    @property
    def laneletLayer(self) -> 'LaneletLayer': ...
    @property
    def areaLayer(self) -> 'AreaLayer': ...
    @property
    def regulatoryElementLayer(self) -> 'RegulatoryElementLayer': ...


class LaneletMap(LaneletMapLayers):
    """A lanelet map collects lanelet primitives. 

    Can be used for writing and loading and creating routing graphs.
    Also offers geometrical and relational queries for its objects.
    Note that this is not the right object for querying neigborhood relations.
    Create a lanelet2.routing.RoutingGraph for this.
    Note that there is a utility function 'createMapFromX' to create a map from a list of primitives.
    """

    def __init__(self) -> None: ...
    def add(self, arg: Union['Point3d', 'LineString3d',
            'Polygon3d', 'Lanelet', 'Area', 'RegulatoryElement']) -> None: ...


class LaneletSubmap(LaneletMapLayers):
    """
    A submap managing parts of a lanelet map.

    An important difference is that adding an object to the map will *not*
    add its subobjects too, making it more efficient to create.
    Apart from that, it offers a similar functionality compared to a lanelet map.
    """

    def __init__(self) -> None: ...
    def laneletMap(self) -> 'LaneletMap': ...
    def add(self, arg: Union['Point3d', 'LineString3d',
            'Polygon3d', 'Lanelet', 'Area', 'RegulatoryElement']) -> None: ...


def getId() -> int: ...


def registerId(id: int) -> None: ...


def createMapFromPoints(points: List['Point3d']) -> 'LaneletMap':
    """
    Create a LaneletMap from a list of points.

    :param points: List of points to include in the map.
    :return: A LaneletMap containing the provided points.
    """
    ...


def createMapFromLineStrings(lineStrings: List['LineString3d']) -> 'LaneletMap':
    """
    Create a LaneletMap from a list of line strings.

    :param lineStrings: List of line strings to include in the map.
    :return: A LaneletMap containing the provided line strings.
    """
    ...


def createMapFromPolygons(polygons: List['Polygon3d']) -> 'LaneletMap':
    """
    Create a LaneletMap from a list of polygons.

    :param polygons: List of polygons to include in the map.
    :return: A LaneletMap containing the provided polygons.
    """
    ...


def createMapFromLanelets(lanelets: List['Lanelet']) -> 'LaneletMap':
    """
    Create a LaneletMap from a list of lanelets.

    :param lanelets: List of lanelets to include in the map.
    :return: A LaneletMap containing the provided lanelets.
    """
    ...


def createMapFromAreas(areas: List['Area']) -> 'LaneletMap':
    """
    Create a LaneletMap from a list of areas.

    :param areas: List of areas to include in the map.
    :return: A LaneletMap containing the provided areas.
    """
    ...


def createMapFromRegulatoryElements(regulatoryElements: List['RegulatoryElement']) -> 'LaneletMap':
    """
    Create a LaneletMap from a list of regulatory elements.

    :param regulatoryElements: List of regulatory elements to include in the map.
    :return: A LaneletMap containing the provided regulatory elements.
    """
    ...


def createSubmapFromPoints(points: List['Point3d']) -> 'LaneletSubmap':
    """
    Create a LaneletSubmap from a list of points.

    :param points: List of points to include in the submap.
    :return: A LaneletSubmap containing the provided points.
    """
    ...


def createSubmapFromLineStrings(lineStrings: List['LineString3d']) -> 'LaneletSubmap':
    """
    Create a LaneletSubmap from a list of line strings.

    :param lineStrings: List of line strings to include in the submap.
    :return: A LaneletSubmap containing the provided line strings.
    """
    ...


def createSubmapFromPolygons(polygons: List['Polygon3d']) -> 'LaneletSubmap':
    """
    Create a LaneletSubmap from a list of polygons.

    :param polygons: List of polygons to include in the submap.
    :return: A LaneletSubmap containing the provided polygons.
    """
    ...


def createSubmapFromLanelets(lanelets: List['Lanelet']) -> 'LaneletSubmap':
    """
    Create a LaneletSubmap from a list of lanelets.

    :param lanelets: List of lanelets to include in the submap.
    :return: A LaneletSubmap containing the provided lanelets.
    """
    ...


def createSubmapFromAreas(areas: List['Area']) -> 'LaneletSubmap':
    """
    Create a LaneletSubmap from a list of areas.

    :param areas: List of areas to include in the submap.
    :return: A LaneletSubmap containing the provided areas.
    """
    ...


def createSubmapFromRegulatoryElements(regulatoryElements: List['RegulatoryElement']) -> 'LaneletSubmap':
    """
    Create a LaneletSubmap from a list of regulatory elements.

    :param regulatoryElements: List of regulatory elements to include in the submap.
    :return: A LaneletSubmap containing the provided regulatory elements.
    """
    ...
